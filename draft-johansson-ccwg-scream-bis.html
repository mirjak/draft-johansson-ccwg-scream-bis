<!DOCTYPE html>
<html lang="en" class="Internet-Draft">
<head>
<meta charset="utf-8">
<meta content="Common,Latin" name="scripts">
<meta content="initial-scale=1.0" name="viewport">
<title>Self-Clocked Rate Adaptation for Multimedia</title>
<meta content="Ingemar Johansson" name="author">
<meta content="Magnus Westerlund" name="author">
<meta content="
       This memo describes a rate adaptation algorithm for conversational
   media services such as interactive video.  The solution conforms to
   the packet conservation principle and uses a hybrid loss-and-delay-
   based congestion control algorithm.  The algorithm is evaluated over
   both simulated Internet bottleneck scenarios as well as in a Long
   Term Evolution (LTE) system simulator and is shown to achieve both
   low latency and high video throughput in these scenarios. 
    " name="description">
<meta content="xml2rfc 3.18.2" name="generator">
<meta content="draft-johansson-ccwg-scream-bis-latest" name="ietf.draft">
<!-- Generator version information:
  xml2rfc 3.18.2
    Python 3.11.5
    ConfigArgParse 1.7
    google-i18n-address 3.1.0
    intervaltree 3.1.0
    Jinja2 3.1.2
    lxml 4.9.3
    platformdirs 4.1.0
    pycountry 23.12.11
    PyYAML 6.0.1
    requests 2.31.0
    setuptools 69.0.2
    six 1.16.0
    wcwidth 0.2.12
-->
<link href="draft-johansson-ccwg-scream-bis.xml" rel="alternate" type="application/rfc+xml">
<link href="#copyright" rel="license">
<style type="text/css">@font-face {
  font-family: 'Lora';
  font-style: italic;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Italic'), local('Lora-Italic'), url('https://martinthomson.github.io/rfc-css/fonts/lora-italic-cyrillic-ext.woff2') format('woff2');
  unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;
}
@font-face {
  font-family: 'Lora';
  font-style: italic;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Italic'), local('Lora-Italic'), url('https://martinthomson.github.io/rfc-css/fonts/lora-italic-cyrillic-ext.woff2') format('woff2');
  unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
}
@font-face {
  font-family: 'Lora';
  font-style: italic;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Italic'), local('Lora-Italic'), url('https://martinthomson.github.io/rfc-css/fonts/lora-italic-vietnamese.woff2') format('woff2');
  unicode-range: U+0102-0103, U+0110-0111, U+1EA0-1EF9, U+20AB;
}
@font-face {
  font-family: 'Lora';
  font-style: italic;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Italic'), local('Lora-Italic'), url('https://martinthomson.github.io/rfc-css/fonts/lora-italic-latin-ext.woff2') format('woff2');
  unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
}

@font-face {
  font-family: 'Lora';
  font-style: italic;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Italic'), local('Lora-Italic'), url('https://martinthomson.github.io/rfc-css/fonts/lora-italic-latin.woff2') format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Regular'), local('Lora-Regular'), url('https://martinthomson.github.io/rfc-css/fonts/lora-regular-cyrillic-ext.woff2') format('woff2');
  unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Regular'), local('Lora-Regular'), url('https://martinthomson.github.io/rfc-css/fonts/lora-regular-cyrillic.woff2') format('woff2');
  unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Regular'), local('Lora-Regular'), url('https://martinthomson.github.io/rfc-css/fonts/lora-regular-vietnamese.woff2') format('woff2');
  unicode-range: U+0102-0103, U+0110-0111, U+1EA0-1EF9, U+20AB;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Regular'), local('Lora-Regular'), url('https://martinthomson.github.io/rfc-css/fonts/lora-regular-latin-ext.woff2') format('woff2');
  unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Regular'), local('Lora-Regular'), url('https://martinthomson.github.io/rfc-css/fonts/lora-regular-latin.woff2') format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}

@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 700;
  font-display: swap;
  src: local('Lora Bold'), local('Lora-Bold'), url('https://martinthomson.github.io/rfc-css/fonts/lora-bold-cyrillic-ext.woff2') format('woff2');
  unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 700;
  font-display: swap;
  src: local('Lora Bold'), local('Lora-Bold'), url('https://martinthomson.github.io/rfc-css/fonts/lora-bold-cyrillic.woff2') format('woff2');
  unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 700;
  font-display: swap;
  src: local('Lora Bold'), local('Lora-Bold'), url('https://martinthomson.github.io/rfc-css/fonts/lora-bold-vietnamese.woff2') format('woff2');
  unicode-range: U+0102-0103, U+0110-0111, U+1EA0-1EF9, U+20AB;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 700;
  font-display: swap;
  src: local('Lora Bold'), local('Lora-Bold'), url('https://martinthomson.github.io/rfc-css/fonts/lora-bold-latin-ext.woff2') format('woff2');
  unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 700;
  font-display: swap;
  src: local('Lora Bold'), local('Lora-Bold'), url('https://martinthomson.github.io/rfc-css/fonts/lora-bold-latin.woff2') format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 600;
  font-display: swap;
  src: local('Lora SemiBold'), local('Lora-SemiBold'), url('https://martinthomson.github.io/rfc-css/fonts/lora-semibold-latin.woff2') format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}

@font-face {
  font-family: 'Cabin Condensed';
  font-style: normal;
  font-weight: 600;
  font-display: swap;
  src: local('Cabin Condensed SemiBold'), local('CabinCondensed-SemiBold'), url('https://martinthomson.github.io/rfc-css/fonts/cabincondensed-semibold-vietnamese.woff2') format('woff2');
  unicode-range: U+0102-0103, U+0110-0111, U+1EA0-1EF9, U+20AB;
}
@font-face {
  font-family: 'Cabin Condensed';
  font-style: normal;
  font-weight: 600;
  font-display: swap;
  src: local('Cabin Condensed SemiBold'), local('CabinCondensed-SemiBold'), url('https://martinthomson.github.io/rfc-css/fonts/cabincondensed-semibold-latin-ext.woff2') format('woff2');
  unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
}
@font-face {
  font-family: 'Cabin Condensed';
  font-style: normal;
  font-weight: 600;
  font-display: swap;
  src: local('Cabin Condensed SemiBold'), local('CabinCondensed-SemiBold'), url('https://martinthomson.github.io/rfc-css/fonts/cabincondensed-semibold-latin.woff2') format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}

@font-face {
  font-family: 'Oxygen Mono';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: local('Oxygen Mono'), local('OxygenMono-Regular'), url('https://martinthomson.github.io/rfc-css/fonts/oxygenmono-regular-latin-ext.woff2') format('woff2');
  unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
}
@font-face {
  font-family: 'Oxygen Mono';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: local('Oxygen Mono'), local('OxygenMono-Regular'), url('https://martinthomson.github.io/rfc-css/fonts/oxygenmono-regular-latin.woff2') format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}

:root {
  color-scheme: light dark;
  --background-color: #fff;
  --text-color: #222;
  --title-color: #191919;
  --link-color: #2a6496;
  --highlight-color: #f9f9f9;
  --line-color: #eee;
  --pilcrow-weak: #ddd;
  --pilcrow-strong: #bbb;
  --small-font-size: 14.5px;
  --font-mono: 'Oxygen Mono', monospace;
  scrollbar-color: #bbb #eee;
}
body {
  max-width: 600px;
  margin: 75px auto;
  padding: 0 5px;
  color: var(--text-color);
  background-color: var(--background-color);
  font: 16px/22px "Lora", serif;
  scroll-behavior: smooth;
}

.ears {
  display: none;
}

/* headings */
h1, h2, h3, h4, h5, h6 {
  font-family: "Cabin Condensed", sans-serif;
  font-weight: 600;
  margin: 0.8em 0 0.3em;
  font-size-adjust: 0.5;
  color: var(--title-color);
}
h1#title {
  font-size: 32px;
  line-height: 40px;
  clear: both;
}
h1#title, h1#rfcnum {
  margin: 1.5em 0 0.2em;
}
h1#rfcnum + h1#title {
  margin: 0.2em 0;
}

h1, h2, h3 {
  font-size: 22px;
  line-height: 27px;
}
h4, h5, h6 {
  font-size: 20px;
  line-height: 24px;
}

/* general structure */
.author {
  padding-bottom: 0.3em;
}
#abstract+p {
  font-size: 18px;
  line-height: 24px;
}
#abstract+p code, #abstract+p samp, #abstract+p tt {
  font-size: 16px;
  line-height: 0;
}

p {
  padding: 0;
  margin: 0.5em 0;
  text-align: left;
}
div {
  margin: 0;
}
.alignRight.art-text {
  background-color: var(--highlight-color);
  border: 1px solid var(--line-color);
  border-radius: 3px;
  padding: 0.5em 1em 0;
  margin-bottom: 0.5em;
}
.alignRight.art-text pre {
  padding: 0;
  width: auto;
}
.alignRight {
  margin: 1em 0;
}
.alignRight > *:first-child {
  border: none;
  margin: 0;
  float: right;
  clear: both;
}
.alignRight > *:nth-child(2) {
  clear: both;
  display: block;
  border: none;
}
svg {
  display: block;
}
/* font-family isn't space-separated, but =~ will have to do */
svg[font-family~="monospace" i], svg [font-family~="monospace" i] {
  font-family: var(--font-mono);
}
.alignCenter.art-text {
  background-color: var(--highlight-color);
  border: 1px solid var(--line-color);
  border-radius: 3px;
  padding: 0.5em 1em 0;
  margin-bottom: 0.5em;
}
.alignCenter.art-text pre {
  padding: 0;
  width: auto;
}
.alignCenter {
  margin: 1em 0;
}
.alignCenter > *:first-child {
  border: none;
  /* this isn't optimal, but it's an existence proof.  PrinceXML doesn't
     support flexbox yet.
  */
  display: table;
  margin: 0 auto;
}

/* lists */
ol, ul {
  padding: 0;
  margin: 0 0 0.5em 2em;
}
:is(ol, ul) :is(ol, ul) {
  margin-left: 1em;
}
li {
  margin: 0 0 0.25em 0;
}
.ulCompact li {
  margin: 0;
}
ul.empty, .ulEmpty {
  list-style-type: none;
}
ul.empty li, .ulEmpty li {
  margin-top: 0.5em;
}
:is(ul, ol).compact, .ulCompact, .olCompact {
  line-height: 1;
  margin: 0 0 0 2em;
}

/* definition lists */
dl {
  clear: left;
  --indent: 3ch;
  /* --indent: attr(indent ch); not supported in any browser, but we can dream */
}
dl.olPercent {
  --indent: 5ch;
}
dl > dt {
  float: left;
  margin-right: 2ch;
  min-width: 8ch;
}
dl.dlNewline > dt {
  float: none;
}
dl > dd {
  margin-bottom: .8em;
  margin-left: var(--indent) !important; /* stupid element overrides */
  min-height: 2ex;
}
dl.olPercent > dt {
  min-width: calc(var(--indent) - 2ch);
}
:is(dl.compact, .dlCompact) > dd {
  margin-bottom: 0;
}
:is(dl.compact, .dlCompact) > dd > :is(:first-child, .break:first-child + *) {
  margin-top: 0;
}
:is(dl.compact, .dlCompact) > dd > :is(:last-child) {
  margin-bottom: 0;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0;
}
:is(dd, span).break {
  display: none;
}

/* links */
a, a[href].selfRef:hover {
  text-decoration: none;
}
a[href] {
  color: var(--link-color);
}
a[href].selfRef, .iref + a[href].internal {
  color: var(--text-color);
}
a[href]:hover {
  text-decoration: underline;
}
a[href].selfRef:hover {
  background-color: var(--highlight-color);
}
a.xref:is(.cite, .auto), :is(#status-of-memo, #copyright) a {
  white-space: nowrap;
}

/* Figures */
tt, code, pre {
  background-color: var(--highlight-color);
  font: 14px/22px var(--font-mono);
}
tt, code {
  /* changing the font for inline elements leads to different ascender
     and descender heights; as we want to retain baseline alignment,
     remove leading to avoid altering the final height of lines
     note: this fails if these blocks take an entire line,
     a different solution would be great */
  line-height: 0;
}
:is(h1, h2, h3, h4, h5, h6) :is(tt, code) {
  font-size: 84%;
}
pre {
  border: 1px solid var(--line-color);
  font-size: 13.5px;
  line-height: 16px;
  letter-spacing: -0.2px;
  margin: 5px;
  padding: 5px;
}
img {
  max-width: 100%;
}
figure {
  margin: 0.5em 0;
  padding: 0;
}
figure blockquote {
  margin: 0.8em 0.4em 0.4em;
}
figcaption, caption {
  font-style: italic;
  margin: 0.5em 1.5em;
  text-align: left;
}
@media screen {
  /* Auto-collapse boilerplate. */
  :is(#status-of-memo, #copyright) p {
    margin: -2px 0;
    max-height: 0;
    transition: max-height 2s ease, margin 0.5s ease 0.5s;
    overflow: hidden;
  }
  :is(#status-of-memo, #copyright):hover p,
  :is(#status-of-memo, #copyright) h2:target ~ p {
    margin: 0.5em 0;
    max-height: 500px;
    overflow: auto;
  }
  pre, svg {
    display: inline-block;
    overflow-x: auto;
  }
  pre {
    max-width: 100%;
    width: calc(100% - 22px - 1em);
  }
  svg {
    max-width: calc(100% - 22px - 1em);
  }
  figure pre {
    display: block;
    width: calc(100% - 25px);
  }
  :is(pre, svg) + .pilcrow {
    display: inline-block;
    vertical-align: text-bottom;
    padding-bottom: 8px;
  }
}

/* aside, blockquote */
aside, blockquote {
  margin-left: 0;
  padding: 0 2em;
  font-style: italic;
}
blockquote {
  margin: 1em 0;
}
cite {
  display: block;
  text-align: right;
  font-style: italic;
}

/* tables */
table {
  max-width: 100%;
  margin: 0 0 1em;
  border-collapse: collapse;
}
table.right {
  margin-left: auto;
}
table.center {
  margin-left: auto;
  margin-right: auto;
}
table.left {
  margin-right: auto;
}
thead, tbody {
  border: 1px solid var(--line-color);
}
th, td {
  text-align: left;
  vertical-align: top;
  padding: 5px 10px;
}
th {
  background-color: var(--line-color);
}
:is(tr:nth-child(2n), thead+tbody > tr:nth-child(2n+1)) > td {
  background-color: var(--background-color);
}
:is(tr:nth-child(2n+1), thead+tbody > tr:nth-child(2n)) > td {
  background-color: var(--highlight-color);
}
table caption {
  margin: 0;
  padding: 3px 0 3px 1em;
}
table p {
  margin: 0;
}

/* pilcrow */
a.pilcrow {
  margin-left: 3px;
  opacity: 0.2;
  user-select: none;
}
a.pilcrow[href] { color: var(--pilcrow-weak); }
a.pilcrow[href]:hover { text-decoration: none; }
@media not print {
  :hover > a.pilcrow {
    opacity: 1;
  }
  a.pilcrow[href]:hover {
    color: var(--pilcrow-strong);
    background-color: transparent;
  }
}
@media print {
  a.pilcrow {
    display: none;
  }
}

/* misc */
hr {
  border: 0;
  border-top: 1px solid var(--line-color);
}
.bcp14 {
  font-variant: small-caps;
  font-weight: 600;
  font-size: var(--small-font-size);
}
.role {
  font-variant: all-small-caps;
}
sub, sup {
  line-height: 1;
  font-size: 80%;
}

/* info block */
#identifiers {
  margin: 0;
  font-size: var(--small-font-size);
  line-height: 18px;
  --identifier-width: 15ch;
}
#identifiers dt {
  width: var(--identifier-width);
  min-width: var(--identifier-width);
  clear: left;
  float: left;
  text-align: right;
  margin-right: 1ch;
}
#identifiers dd {
  margin: 0;
  margin-left: calc(1em + var(--identifier-width)) !important;
  min-width: 5em;
}
#identifiers .authors .author {
  display: inline-block;
  margin-right: 1.5em;
}
#identifiers .authors .org {
  font-style: italic;
}

/* The prepared/rendered info at the very bottom of the page */
.docInfo {
  color: #999;
  font-size: 0.9em;
  font-style: italic;
  margin-top: 2em;
}
.docInfo .prepared {
  float: left;
}
.docInfo .prepared {
  float: right;
}

/* table of contents */
#toc {
  padding: 0.75em 0 2em 0;
  margin-bottom: 1em;
}
#toc nav ul {
  margin: 0 0.5em 0 0;
  padding: 0;
  list-style: none;
}
#toc nav li {
  line-height: 1.3em;
  margin: 2px 0;
  padding-left: 1.2em;
  text-indent: -1.2em;
}
#toc a.xref {
  white-space: normal;
}
/* references */
.references dt {
  text-align: right;
  font-weight: bold;
  min-width: 10ch;
  margin-right: 1.5ch;
}
.references dt:target::before {
  content: "⇒";
  width: 15px;
  margin: 0 10px 0 -25px;
}
.references dd {
  margin-left: 12ch !important;
  overflow: auto;
}

.refInstance {
  margin-bottom: 1.25em;
}

.references .ascii {
  margin-bottom: 0.25em;
}

/* index */
#rfc\.index\.index + ul {
  margin-left: 0;
}

/* authors */
address.vcard {
  font-style: normal;
  margin: 1em 0;
}
address.vcard .nameRole {
  font-weight: 700;
  margin-left: 0;
}
address.vcard .label {
  margin: 0.5em 0;
}
address.vcard .type {
  display: none;
}
.alternative-contact {
  margin: 1.5em 0 1em;
}
hr.addr {
  border-top: 1px dashed;
  margin: 0;
  color: #ddd;
  max-width: calc(100% - 16px);
}
@media (min-width: 500px) {
  #authors-addresses > section {
    column-count: 2;
    column-gap: 20px;
  }
  #authors-addresses > section > h2 {
    column-span: all;
  }
  /* hack for break-inside: avoid-column */
  #authors-addresses address {
    display: inline-block;
    break-inside: avoid-column;
  }
}

.rfcEditorRemove p:first-of-type {
  font-style: italic;
}
.cref {
  background-color: rgba(249, 232, 105, 0.3);
  padding: 2px 4px;
}
.crefSource {
  font-style: italic;
}
/* alternative layout for smaller screens */
@media screen and (max-width: 929px) {
  #toc {
    position: fixed;
    z-index: 2;
    top: 0;
    right: 0;
    padding: 1px 0 0 0;
    margin: 0;
    border-bottom: 1px solid #ccc;
    opacity: 0.6;
  }
  #toc.active {
      opacity: 1;
  }
  #toc h2 {
    margin: 0;
    padding: 2px 0 2px 6px;
    padding-right: 1em;
    font-size: 18px;
    line-height: 24px;
    min-width: 190px;
    text-align: right;
    background-color: #444;
    color: white;
    cursor: pointer;
  }
  #toc h2::before { /* css hamburger */
    float: right;
    position: relative;
    width: 1em;
    height: 1px;
    left: -164px;
    margin: 8px 0 0 0;
    background: white none repeat scroll 0 0;
    box-shadow: 0 4px 0 0 white, 0 8px 0 0 white;
    content: "";
  }
  #toc nav {
    display: none;
    background-color: var(--background-color);
    padding: 0.5em 1em 1em;
    overflow: auto;
    overscroll-behavior: contain;
    height: calc(100vh - 48px);
    border-left: 1px solid #ddd;
  }
  #toc.active nav {
    display: block;
  }
  /* Make the collapsed ToC header render white on gray also when it's a link */
  #toc h2 a,
  #toc h2 a:link,
  #toc h2 a:focus,
  #toc h2 a:hover,
  #toc a.toplink,
  #toc a.toplink:hover {
    color: white;
    background-color: #444;
    text-decoration: none;
  }
  #toc a.toplink {
    margin-top: 2px;
  }
}

/* alternative layout for wide screens */
@media screen and (min-width: 930px) {
  body {
    padding-right: 360px;
    padding-right: calc(min(180px + 20%, 500px));
  }
  #toc {
    position: fixed;
    bottom: 0;
    right: 0;
    right: calc(50vw - 480px);
    width: 312px;
    margin: 0;
    padding: 0;
    z-index: 1;
  }
  #toc h2 {
    margin: 0;
    padding: 0.25em 1em 1em 0;
  }
  #toc nav {
    display: block;
    height: calc(90vh - 84px);
    bottom: 0;
    padding: 0.5em 0 2em;
    overflow: auto;
    overscroll-behavior: contain;
    scrollbar-width: thin;
  }
  #toc nav > ul  {
    margin-bottom: 2em;
  }
  #toc ul {
    margin: 0 0 0 4px;
    font-size: var(--small-font-size);
  }
  #toc ul :is(p, li) {
    margin: 2px 0;
    line-height: 22px;
  }
  img { /* future proofing */
    max-width: 100%;
    height: auto;
  }
}

/* pagination */
@media print {
  body {
    width: 100%;
  }
  p {
    orphans: 3;
    widows: 3;
  }
  #n-copyright-notice {
    border-bottom: none;
  }
  #toc, #n-introduction {
    page-break-before: always;
  }
  #toc {
    border-top: none;
    padding-top: 0;
  }
  figure, pre, .vcard {
    page-break-inside: avoid;
  }
  h1, h2, h3, h4, h5, h6 {
    page-break-after: avoid;
  }
  :is(h2, h3, h4, h5, h6)+*, dd {
    page-break-before: avoid;
  }
  pre {
    white-space: pre-wrap;
    word-wrap: break-word;
    font-size: 10pt;
  }
  table {
    border: 1px solid #ddd;
  }
  td {
    border-top: 1px solid #ddd;
  }
  .toplink {
    display: none;
  }
}

@page :first {
  padding-top: 0;
  @top-left {
    content: normal;
    border: none;
  }
  @top-center {
    content: normal;
    border: none;
  }
  @top-right {
    content: normal;
    border: none;
  }
}

@page {
  size: A4;
  margin-bottom: 45mm;
  padding-top: 20px;
}

/* Changes introduced to fix issues found during implementation */

/* Separate body from document info even without intervening H1 */
section {
  clear: both;
}

/* Top align author divs, to avoid names without organization dropping level with org names */
.author {
  vertical-align: top;
}

/* Style section numbers with more space between number and title */
.section-number {
  padding-right: 0.5em;
}

/* Add styling for a link in the ToC that points to the top of the document */
a.toplink {
  float: right;
  margin: 8px 0.5em 0;
}

/* Provide styling for table cell text alignment */
table .text-left {
  text-align: left;
}
table .text-center {
  text-align: center;
}
table .text-right {
  text-align: right;
}

/* Make the alternative author contact information look less like just another
   author, and group it closer with the primary author contact information */
.alternative-contact {
  margin: 0.5em 0 0.25em 0;
}
address .non-ascii {
  margin: 0 0 0 2em;
}

/* With it being possible to set tables with alignment
  left, center, and right, { width: 100%; } does not make sense */
table {
  width: auto;
}

/* Avoid reference text that sits in a block with very wide left margin,
   because of a long floating dt label.*/
.references dd {
  overflow: visible;
}

/* Control caption placement */
caption {
  caption-side: bottom;
}

/* Limit the width of the author address vcard, so names in right-to-left
   script don't end up on the other side of the page. */

address.vcard {
  max-width: 20em;
  margin-right: auto;
}

/* For address alignment dependent on LTR or RTL scripts */
address div.left {
  text-align: left;
}
address div.right {
  text-align: right;
}

/* Dark mode. */
@media (prefers-color-scheme: dark) {
:root {
  --background-color: #121212;
  --text-color: #f0f0f0;
  --title-color: #fff;
  --link-color: #4da4f0;
  --highlight-color: #282828;
  --line-color: #444;
  --pilcrow-weak: #444;
  --pilcrow-strong: #666;
  scrollbar-color: #777 #333;
}
}

/* SVG Trick: a prefix match works because only black and white are allowed */
svg :is([stroke="black"], [stroke^="#000"]) {
  stroke: var(--text-color);
}
svg :is([stroke="white"], [stroke^="#fff"]) {
  stroke: var(--background-color);
}
svg :is([fill="black"], [fill^="#000"], :not([fill])) {
  fill: var(--text-color);
}
svg :is([fill="white"], [fill^="#fff"]) {
  fill: var(--background-color);
}
</style>

</head>
<body class="xml2rfc">
<table class="ears">
<thead><tr>
<td class="left">Internet-Draft</td>
<td class="center">SCREAM</td>
<td class="right">December 2023</td>
</tr></thead>
<tfoot><tr>
<td class="left">Johansson &amp; Westerlund</td>
<td class="center">Expires 20 June 2024</td>
<td class="right">[Page]</td>
</tr></tfoot>
</table>
<div id="external-metadata" class="document-information"></div>
<div id="internal-metadata" class="document-information">
<dl id="identifiers">
<dt class="label-workgroup">Workgroup:</dt>
<dd class="workgroup">CCWG</dd>
<dt class="label-internet-draft">Internet-Draft:</dt>
<dd class="internet-draft">draft-johansson-ccwg-scream-bis-latest</dd>
<dt class="label-obsoletes">Obsoletes:</dt>
<dd class="obsoletes">
<a href="https://www.rfc-editor.org/rfc/rfc8298" class="eref">8298</a> (if approved)</dd>
<dt class="label-published">Published:</dt>
<dd class="published">
<time datetime="2023-12-18" class="published">18 December 2023</time>
    </dd>
<dt class="label-intended-status">Intended Status:</dt>
<dd class="intended-status">Experimental</dd>
<dt class="label-expires">Expires:</dt>
<dd class="expires"><time datetime="2024-06-20">20 June 2024</time></dd>
<dt class="label-authors">Authors:</dt>
<dd class="authors">
<div class="author">
      <div class="author-name">I. Johansson</div>
<div class="org">Ericsson</div>
</div>
<div class="author">
      <div class="author-name">M. Westerlund</div>
<div class="org">Ericsson</div>
</div>
</dd>
</dl>
</div>
<h1 id="title">Self-Clocked Rate Adaptation for Multimedia</h1>
<section id="section-abstract">
      <h2 id="abstract"><a href="#abstract" class="selfRef">Abstract</a></h2>
<p id="section-abstract-1">This memo describes a rate adaptation algorithm for conversational
   media services such as interactive video.  The solution conforms to
   the packet conservation principle and uses a hybrid loss-and-delay-
   based congestion control algorithm.  The algorithm is evaluated over
   both simulated Internet bottleneck scenarios as well as in a Long
   Term Evolution (LTE) system simulator and is shown to achieve both
   low latency and high video throughput in these scenarios.<a href="#section-abstract-1" class="pilcrow">¶</a></p>
</section>
<section class="note rfcEditorRemove" id="section-note.1">
      <h2 id="name-about-this-document">
<a href="#name-about-this-document" class="section-name selfRef">About This Document</a>
      </h2>
<p id="section-note.1-1">This note is to be removed before publishing as an RFC.<a href="#section-note.1-1" class="pilcrow">¶</a></p>
<p id="section-note.1-2">
        Status information for this document may be found at <span><a href="https://datatracker.ietf.org/doc/draft-johansson-ccwg-scream-bis/">https://datatracker.ietf.org/doc/draft-johansson-ccwg-scream-bis/</a></span>.<a href="#section-note.1-2" class="pilcrow">¶</a></p>
<p id="section-note.1-3">
        Discussion of this document takes place on the
        Congestion Control Working Group (ccwg) Working Group mailing list (<span><a href="mailto:ccwg@ietf.org">mailto:ccwg@ietf.org</a></span>),
        which is archived at <span><a href="https://mailarchive.ietf.org/arch/browse/ccwg/">https://mailarchive.ietf.org/arch/browse/ccwg/</a></span>.
        Subscribe at <span><a href="https://www.ietf.org/mailman/listinfo/ccwg/">https://www.ietf.org/mailman/listinfo/ccwg/</a></span>.<a href="#section-note.1-3" class="pilcrow">¶</a></p>
<p id="section-note.1-4">Source for this draft and an issue tracker can be found at
        <span><a href="https://github.com/gloinul/draft-johansson-ccwg-scream-bis">https://github.com/gloinul/draft-johansson-ccwg-scream-bis</a></span>.<a href="#section-note.1-4" class="pilcrow">¶</a></p>
</section>
<div id="status-of-memo">
<section id="section-boilerplate.1">
        <h2 id="name-status-of-this-memo">
<a href="#name-status-of-this-memo" class="section-name selfRef">Status of This Memo</a>
        </h2>
<p id="section-boilerplate.1-1">
        This Internet-Draft is submitted in full conformance with the
        provisions of BCP 78 and BCP 79.<a href="#section-boilerplate.1-1" class="pilcrow">¶</a></p>
<p id="section-boilerplate.1-2">
        Internet-Drafts are working documents of the Internet Engineering Task
        Force (IETF). Note that other groups may also distribute working
        documents as Internet-Drafts. The list of current Internet-Drafts is
        at <span><a href="https://datatracker.ietf.org/drafts/current/">https://datatracker.ietf.org/drafts/current/</a></span>.<a href="#section-boilerplate.1-2" class="pilcrow">¶</a></p>
<p id="section-boilerplate.1-3">
        Internet-Drafts are draft documents valid for a maximum of six months
        and may be updated, replaced, or obsoleted by other documents at any
        time. It is inappropriate to use Internet-Drafts as reference
        material or to cite them other than as "work in progress."<a href="#section-boilerplate.1-3" class="pilcrow">¶</a></p>
<p id="section-boilerplate.1-4">
        This Internet-Draft will expire on 20 June 2024.<a href="#section-boilerplate.1-4" class="pilcrow">¶</a></p>
</section>
</div>
<div id="copyright">
<section id="section-boilerplate.2">
        <h2 id="name-copyright-notice">
<a href="#name-copyright-notice" class="section-name selfRef">Copyright Notice</a>
        </h2>
<p id="section-boilerplate.2-1">
            Copyright (c) 2023 IETF Trust and the persons identified as the
            document authors. All rights reserved.<a href="#section-boilerplate.2-1" class="pilcrow">¶</a></p>
<p id="section-boilerplate.2-2">
            This document is subject to BCP 78 and the IETF Trust's Legal
            Provisions Relating to IETF Documents
            (<span><a href="https://trustee.ietf.org/license-info">https://trustee.ietf.org/license-info</a></span>) in effect on the date of
            publication of this document. Please review these documents
            carefully, as they describe your rights and restrictions with
            respect to this document. Code Components extracted from this
            document must include Revised BSD License text as described in
            Section 4.e of the Trust Legal Provisions and are provided without
            warranty as described in the Revised BSD License.<a href="#section-boilerplate.2-2" class="pilcrow">¶</a></p>
</section>
</div>
<div id="toc">
<section id="section-toc.1">
        <a href="#" onclick="scroll(0,0)" class="toplink">▲</a><h2 id="name-table-of-contents">
<a href="#name-table-of-contents" class="section-name selfRef">Table of Contents</a>
        </h2>
<nav class="toc"><ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.1">
            <p id="section-toc.1-1.1.1" class="keepWithNext"><a href="#section-1" class="auto internal xref">1</a>.  <a href="#name-introduction" class="internal xref">Introduction</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.1.2.1">
                <p id="section-toc.1-1.1.2.1.1" class="keepWithNext"><a href="#section-1.1" class="auto internal xref">1.1</a>.  <a href="#name-wireless-lte-access-propert" class="internal xref">Wireless (LTE) Access Properties</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.1.2.2">
                <p id="section-toc.1-1.1.2.2.1" class="keepWithNext"><a href="#section-1.2" class="auto internal xref">1.2</a>.  <a href="#name-why-is-it-a-self-clocked-al" class="internal xref">Why is it a self-clocked algorithm?</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.2">
            <p id="section-toc.1-1.2.1"><a href="#section-2" class="auto internal xref">2</a>.  <a href="#name-requirements-language" class="internal xref">Requirements Language</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3">
            <p id="section-toc.1-1.3.1"><a href="#section-3" class="auto internal xref">3</a>.  <a href="#name-overview-of-scream-algorith" class="internal xref">Overview of SCReAM Algorithm</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.1">
                <p id="section-toc.1-1.3.2.1.1"><a href="#section-3.1" class="auto internal xref">3.1</a>.  <a href="#name-network-congestion-control" class="internal xref">Network Congestion Control</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.2">
                <p id="section-toc.1-1.3.2.2.1"><a href="#section-3.2" class="auto internal xref">3.2</a>.  <a href="#name-sender-transmission-control" class="internal xref">Sender Transmission Control</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.3">
                <p id="section-toc.1-1.3.2.3.1"><a href="#section-3.3" class="auto internal xref">3.3</a>.  <a href="#name-media-rate-control" class="internal xref">Media Rate Control</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4">
            <p id="section-toc.1-1.4.1"><a href="#section-4" class="auto internal xref">4</a>.  <a href="#name-detailed-description-of-scr" class="internal xref">Detailed Description of SCReAM</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.1">
                <p id="section-toc.1-1.4.2.1.1"><a href="#section-4.1" class="auto internal xref">4.1</a>.  <a href="#name-scream-sender" class="internal xref">SCReAM Sender</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.1.2.1">
                    <p id="section-toc.1-1.4.2.1.2.1.1"><a href="#section-4.1.1" class="auto internal xref">4.1.1</a>.  <a href="#name-constants-and-parameter-val" class="internal xref">Constants and Parameter Values</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.1.2.2">
                    <p id="section-toc.1-1.4.2.1.2.2.1"><a href="#section-4.1.2" class="auto internal xref">4.1.2</a>.  <a href="#name-network-congestion-control-2" class="internal xref">Network Congestion Control</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.1.2.3">
                    <p id="section-toc.1-1.4.2.1.2.3.1"><a href="#section-4.1.3" class="auto internal xref">4.1.3</a>.  <a href="#name-media-rate-control-2" class="internal xref">Media Rate Control</a></p>
</li>
                </ul>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.2">
                <p id="section-toc.1-1.4.2.2.1"><a href="#section-4.2" class="auto internal xref">4.2</a>.  <a href="#name-scream-receiver" class="internal xref">SCReAM Receiver</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.2.2.1">
                    <p id="section-toc.1-1.4.2.2.2.1.1"><a href="#section-4.2.1" class="auto internal xref">4.2.1</a>.  <a href="#name-requirements-on-feedback-el" class="internal xref">Requirements on Feedback Elements</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.2.2.2">
                    <p id="section-toc.1-1.4.2.2.2.2.1"><a href="#section-4.2.2" class="auto internal xref">4.2.2</a>.  <a href="#name-requirements-on-feedback-in" class="internal xref">Requirements on Feedback Intensity</a></p>
</li>
                </ul>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5">
            <p id="section-toc.1-1.5.1"><a href="#section-5" class="auto internal xref">5</a>.  <a href="#name-discussion" class="internal xref">Discussion</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.6">
            <p id="section-toc.1-1.6.1"><a href="#section-6" class="auto internal xref">6</a>.  <a href="#name-suggested-experiments" class="internal xref">Suggested Experiments</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7">
            <p id="section-toc.1-1.7.1"><a href="#section-7" class="auto internal xref">7</a>.  <a href="#name-iana-considerations" class="internal xref">IANA Considerations</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.8">
            <p id="section-toc.1-1.8.1"><a href="#section-8" class="auto internal xref">8</a>.  <a href="#name-security-considerations" class="internal xref">Security Considerations</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.9">
            <p id="section-toc.1-1.9.1"><a href="#section-9" class="auto internal xref">9</a>.  <a href="#name-references" class="internal xref">References</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.9.2.1">
                <p id="section-toc.1-1.9.2.1.1"><a href="#section-9.1" class="auto internal xref">9.1</a>.  <a href="#name-normative-references" class="internal xref">Normative References</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.9.2.2">
                <p id="section-toc.1-1.9.2.2.1"><a href="#section-9.2" class="auto internal xref">9.2</a>.  <a href="#name-informative-references" class="internal xref">Informative References</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.10">
            <p id="section-toc.1-1.10.1"><a href="#appendix-A" class="auto internal xref">Appendix A</a>.  <a href="#name-acknowledgments" class="internal xref">Acknowledgments</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.11">
            <p id="section-toc.1-1.11.1"><a href="#appendix-B" class="auto internal xref"></a><a href="#name-authors-addresses" class="internal xref">Authors' Addresses</a></p>
</li>
        </ul>
</nav>
</section>
</div>
<div id="introduction">
<section id="section-1">
      <h2 id="name-introduction">
<a href="#section-1" class="section-number selfRef">1. </a><a href="#name-introduction" class="section-name selfRef">Introduction</a>
      </h2>
<p id="section-1-1">Congestion in the Internet occurs when the transmitted bitrate is
   higher than the available capacity over a given transmission path.
   Applications that are deployed in the Internet have to employ
   congestion control to achieve robust performance and to avoid
   congestion collapse in the Internet.  Interactive real-time
   communication imposes a lot of requirements on the transport;
   therefore, a robust, efficient rate adaptation for all access types
   is an important part of interactive real-time communications, as the
   transmission channel bandwidth can vary over time.  Wireless access
   such as LTE, which is an integral part of the current Internet,
   increases the importance of rate adaptation as the channel bandwidth
   of a default LTE bearer <span>[<a href="#QoS-3GPP" class="cite xref">QoS-3GPP</a>]</span> can change considerably in a very
   short time frame.  Thus, a rate adaptation solution for interactive
   real-time media, such as WebRTC <span>[<a href="#RFC7478" class="cite xref">RFC7478</a>]</span>, should be both quick and
   be able to operate over a large range in channel capacity.  This memo
   describes Self-Clocked Rate Adaptation for Multimedia (SCReAM), a
   solution that implements congestion control for RTP streams
   <span>[<a href="#RFC3550" class="cite xref">RFC3550</a>]</span>.  While SCReAM was originally devised for WebRTC, it can
   also be used for other applications where congestion control of RTP
   streams is necessary.  SCReAM is based on the self-clocking principle
   of TCP and uses techniques similar to what is used in the rate
   adaptation algorithm based on Low Extra Delay Background Transport
   (LEDBAT) <span>[<a href="#RFC6817" class="cite xref">RFC6817</a>]</span>.  SCReAM is not entirely self-clocked as it
   augments self-clocking with pacing and a minimum send rate.  SCReAM
   can take advantage of Explicit Congestion Notification (ECN) in cases
   where ECN is supported by the network and the hosts.  However, ECN is
   not required for the basic congestion control functionality in
   SCReAM.<a href="#section-1-1" class="pilcrow">¶</a></p>
<div id="wireless-lte-access-properties">
<section id="section-1.1">
        <h3 id="name-wireless-lte-access-propert">
<a href="#section-1.1" class="section-number selfRef">1.1. </a><a href="#name-wireless-lte-access-propert" class="section-name selfRef">Wireless (LTE) Access Properties</a>
        </h3>
<p id="section-1.1-1"><span>[<a href="#RFC8869" class="cite xref">RFC8869</a>]</span> describes the complications that can be observed in
   wireless environments.  Wireless access such as LTE typically cannot
   guarantee a given bandwidth; this is true especially for default
   bearers.  The network throughput can vary considerably, for instance,
   in cases where the wireless terminal is moving around.  Even though
   LTE can support bitrates well above 100 Mbps, there are cases when
   the available bitrate can be much lower; examples are situations with
   high network load and poor coverage.  An additional complication is
   that the network throughput can drop for short time intervals (e.g.,
   at handover); these short glitches are initially very difficult to
   distinguish from more permanent reductions in throughput.<a href="#section-1.1-1" class="pilcrow">¶</a></p>
<p id="section-1.1-2">Unlike wireline bottlenecks with large statistical multiplexing, it
   is not possible to try to maintain a given bitrate when congestion is
   detected with the hope that other flows will yield.  This is because
   there are generally few other flows competing for the same
   bottleneck.  Each user gets its own variable throughput bottleneck,
   where the throughput depends on factors like channel quality, network
   load, and historical throughput.  The bottom line is, if the
   throughput drops, the sender has no other option than to reduce the
   bitrate.  Once the radio scheduler has reduced the resource
   allocation for a bearer, a flow (which is using RTP Media Congestion
   Avoidance Techniques (RMCAT)) in that bearer aims to reduce the
   sending rate quite quickly (within one RTT) in order to avoid
   excessive queuing delay or packet loss.<a href="#section-1.1-2" class="pilcrow">¶</a></p>
</section>
</div>
<div id="why-is-it-a-self-clocked-algorithm">
<section id="section-1.2">
        <h3 id="name-why-is-it-a-self-clocked-al">
<a href="#section-1.2" class="section-number selfRef">1.2. </a><a href="#name-why-is-it-a-self-clocked-al" class="section-name selfRef">Why is it a self-clocked algorithm?</a>
        </h3>
<p id="section-1.2-1">Self-clocked congestion control algorithms provide a benefit over
   their rate-based counterparts in that the former consists of two
   adaptation mechanisms:<a href="#section-1.2-1" class="pilcrow">¶</a></p>
<p id="section-1.2-2">o  A congestion window computation that evolves over a longer
      timescale (several RTTs) especially when the congestion window
      evolution is dictated by estimated delay (to minimize
      vulnerability to, e.g., short-term delay variations).<a href="#section-1.2-2" class="pilcrow">¶</a></p>
<p id="section-1.2-3">o  A fine-grained congestion control given by the self-clocking; it
      operates on a shorter time scale (1 RTT).  The benefits of self-
      clocking are also elaborated upon in <span>[<a href="#TFWC" class="cite xref">TFWC</a>]</span>.<a href="#section-1.2-3" class="pilcrow">¶</a></p>
<p id="section-1.2-4">A rate-based congestion control algorithm typically adjusts the rate
   based on delay and loss.  The congestion detection needs to be done
   with a certain time lag to avoid overreaction to spurious congestion
   events such as delay spikes.  Despite the fact that there are two or
   more congestion indications, the outcome is that there is still only
   one mechanism to adjust the sending rate.  This makes it difficult to
   reach the goals of high throughput and prompt reaction to congestion.<a href="#section-1.2-4" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="requirements-language">
<section id="section-2">
      <h2 id="name-requirements-language">
<a href="#section-2" class="section-number selfRef">2. </a><a href="#name-requirements-language" class="section-name selfRef">Requirements Language</a>
      </h2>
<p id="section-2-1">The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
   "OPTIONAL" in this document are to be interpreted as described in
   BCP 14 <span>[<a href="#RFC2119" class="cite xref">RFC2119</a>]</span> <span>[<a href="#RFC8174" class="cite xref">RFC8174</a>]</span> when, and only when, they appear in all
   capitals, as shown here.<a href="#section-2-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="overview-of-scream-algorithm">
<section id="section-3">
      <h2 id="name-overview-of-scream-algorith">
<a href="#section-3" class="section-number selfRef">3. </a><a href="#name-overview-of-scream-algorith" class="section-name selfRef">Overview of SCReAM Algorithm</a>
      </h2>
<p id="section-3-1">The core SCReAM algorithm has similarities to the concepts of self-
   clocking used in TCP-friendly window-based congestion control <span>[<a href="#TFWC" class="cite xref">TFWC</a>]</span>
   and follows the packet conservation principle.  The packet
   conservation principle is described as a key factor behind the
   protection of networks from congestion <span>[<a href="#Packet-conservation" class="cite xref">Packet-conservation</a>]</span>.<a href="#section-3-1" class="pilcrow">¶</a></p>
<p id="section-3-2">In SCReAM, the receiver of the media echoes a list of received RTP
   packets and the timestamp of the RTP packet with the highest sequence
   number back to the sender in feedback packets.  The sender keeps a
   list of transmitted packets, their respective sizes, and the time
   they were transmitted.  This information is used to determine the
   number of bytes that can be transmitted at any given time instant.  A
   congestion window puts an upper limit on how many bytes can be in
   flight, i.e., transmitted but not yet acknowledged.<a href="#section-3-2" class="pilcrow">¶</a></p>
<p id="section-3-3">The congestion window is determined in a way similar to LEDBAT
   <span>[<a href="#RFC6817" class="cite xref">RFC6817</a>]</span>.  LEDBAT is a congestion control algorithm that uses send
   and receive timestamps to estimate the queuing delay (from now on
   denoted "qdelay") along the transmission path.  This information is
   used to adjust the congestion window.  The use of LEDBAT ensures that
   the end-to-end latency is kept low.  <span>[<a href="#LEDBAT-delay-impact" class="cite xref">LEDBAT-delay-impact</a>]</span> shows that
   LEDBAT has certain inherent issues that make it counteract its
   purpose of achieving low delay.  The general problem described in the
   paper is that the base delay is offset by LEDBAT's own queue buildup.
   The big difference with using LEDBAT in the SCReAM context lies in
   the facts that the source is rate limited and that the RTP queue must
   be kept short (preferably empty).  In addition, the output from a
   video encoder is rarely constant bitrate; static content (talking
   heads, for instance) gives almost zero video bitrate.  This yields
   two useful properties when LEDBAT is used with SCReAM; they help to
   avoid the issues described in <span>[<a href="#LEDBAT-delay-impact" class="cite xref">LEDBAT-delay-impact</a>]</span>:<a href="#section-3-3" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-3-4">
<li id="section-3-4.1">
          <p id="section-3-4.1.1">There is always a certain probability that SCReAM is short of
data to transmit; this means that the network queue will become
empty every once in a while.<a href="#section-3-4.1.1" class="pilcrow">¶</a></p>
</li>
        <li id="section-3-4.2">
          <p id="section-3-4.2.1">The max video bitrate can be lower than the link capacity.  If
the max video bitrate is 5 Mbps and the capacity is 10 Mbps, then
the network queue will become empty.<a href="#section-3-4.2.1" class="pilcrow">¶</a></p>
</li>
      </ol>
<p id="section-3-5">It is sufficient that any of the two conditions above is fulfilled to
   make the base delay update properly.  Furthermore,
   <span>[<a href="#LEDBAT-delay-impact" class="cite xref">LEDBAT-delay-impact</a>]</span> describes an issue with short-lived competing
   flows.  In SCReAM, these short-lived flows will cause the self-
   clocking to slow down, thereby building up the RTP queue; in turn,
   this results in a reduced media video bitrate.  Thus, SCReAM slows
   the bitrate more when there are competing short-lived flows than the
   traditional use of LEDBAT does.  The basic functionality in the use
   of LEDBAT in SCReAM is quite simple; however, there are a few steps
   in order to make the concept work with conversational media:<a href="#section-3-5" class="pilcrow">¶</a></p>
<p id="section-3-6">o  Congestion window validation techniques.  These are similar to the
      method described in <span>[<a href="#RFC7661" class="cite xref">RFC7661</a>]</span>.  Congestion window validation
      ensures that the congestion window is limited by the actual number
      bytes in flight; this is important especially in the context of
      rate-limited sources such as video.  Lack of congestion window
      validation would lead to a slow reaction to congestion as the
      congestion window does not properly reflect the congestion state
      in the network.  The allowed idle period in this memo is shorter
      than in <span>[<a href="#RFC7661" class="cite xref">RFC7661</a>]</span>; this to avoid excessive delays in the cases
      where, e.g., wireless throughput has decreased during a period
      where the output bitrate from the media coder has been low (for
      instance, due to inactivity).  Furthermore, this memo allows for
      more relaxed rules for when the congestion window is allowed to
      grow; this is necessary as the variable output bitrate generally
      means that the congestion window is often underutilized.<a href="#section-3-6" class="pilcrow">¶</a></p>
<p id="section-3-7">o  Fast increase mode makes the bitrate increase faster when no
      congestion is detected.  It makes the media bitrate ramp up within
      5 to 10 seconds.  The behavior is similar to TCP slowstart.  Fast
      increase mode is exited when congestion is detected.  However,
      fast increase mode can resume if the congestion level is low; this
      enables a reasonably quick rate increase in case link throughput
      increases.<a href="#section-3-7" class="pilcrow">¶</a></p>
<p id="section-3-8">o  A qdelay trend is computed for earlier detection of incipient
      congestion; as a result, it reduces jitter.<a href="#section-3-8" class="pilcrow">¶</a></p>
<p id="section-3-9">o  Addition of a media rate control function.<a href="#section-3-9" class="pilcrow">¶</a></p>
<p id="section-3-10">o  Use of inflection points in the media rate calculation to achieve
      reduced jitter.<a href="#section-3-10" class="pilcrow">¶</a></p>
<p id="section-3-11">o  Adjustment of qdelay target for better performance when competing
      with other loss-based congestion-controlled flows.<a href="#section-3-11" class="pilcrow">¶</a></p>
<p id="section-3-12">The above-mentioned features will be described in more detail in
   Sections 3.1 to 3.3.  The full details are described in Section 4.<a href="#section-3-12" class="pilcrow">¶</a></p>
<span id="name-scream-sender-functional-vi"></span><div id="func-view">
<figure id="figure-1">
        <div class="alignLeft art-text artwork" id="section-3-13.1">
<pre>
                    +---------------------------+
                    |        Media encoder      |
                    +---------------------------+
                        ^                  |
                        |                  |(1)
                        |(3)              RTP
                        |                  V
                        |            +-----------+
                   +---------+       |           |
                   | Media   |  (2)  |   Queue   |
                   | rate    |&lt;------|           |
                   | control |       |RTP packets|
                   +---------+       |           |
                                     +-----------+
                                           |
                                           |(4)
                                          RTP
                                           |
                                           v
              +------------+       +--------------+
              |  Network   |  (7)  |    Sender    |
          +--&gt;| congestion |------&gt;| Transmission |
          |   |  control   |       |   Control    |
          |   +------------+       +--------------+
          |                                |
          |-------------RTCP----------|    |(5)
              (6)                     |   RTP
                                      |    v
                                  +------------+
                                  |     UDP    |
                                  |   socket   |
                                  +------------+
</pre>
</div>
<figcaption><a href="#figure-1" class="selfRef">Figure 1</a>:
<a href="#name-scream-sender-functional-vi" class="selfRef">SCReAM Sender Functional View</a>
        </figcaption></figure>
</div>
<p id="section-3-14">The SCReAM algorithm consists of three main parts: network congestion
   control, sender transmission control, and media rate control.  All of
   these parts reside at the sender side.  Figure 1 shows the functional
   overview of a SCReAM sender.  The receiver-side algorithm is very
   simple in comparison, as it only generates feedback containing
   acknowledgements of received RTP packets and an ECN count.<a href="#section-3-14" class="pilcrow">¶</a></p>
<div id="network-congestion-control">
<section id="section-3.1">
        <h3 id="name-network-congestion-control">
<a href="#section-3.1" class="section-number selfRef">3.1. </a><a href="#name-network-congestion-control" class="section-name selfRef">Network Congestion Control</a>
        </h3>
<p id="section-3.1-1">The network congestion control sets an upper limit on how much data
   can be in the network (bytes in flight); this limit is called CWND
   (congestion window) and is used in the sender transmission control.<a href="#section-3.1-1" class="pilcrow">¶</a></p>
<p id="section-3.1-2">The SCReAM congestion control method uses techniques similar to
   LEDBAT <span>[<a href="#RFC6817" class="cite xref">RFC6817</a>]</span>ß to measure the qdelay.  As is the case with LEDBAT,
   it is not necessary to use synchronized clocks in the sender and
   receiver in order to compute the qdelay.  However, it is necessary
   that they use the same clock frequency, or that the clock frequency
   at the receiver can be inferred reliably by the sender.  Failure to
   meet this requirement leads to malfunction in the SCReAM congestion
   control algorithm due to incorrect estimation of the network queue
   delay.<a href="#section-3.1-2" class="pilcrow">¶</a></p>
<p id="section-3.1-3">The SCReAM sender calculates the congestion window based on the
   feedback from the SCReAM receiver.  The congestion window is allowed
   to increase if the qdelay is below a predefined qdelay target;
   otherwise, the congestion window decreases.  The qdelay target is
   typically set to 50-100 ms.  This ensures that the queuing delay is
   kept low.  The reaction to loss or ECN events leads to an instant
   reduction of CWND.  Note that the source rate-limited nature of real-
   time media, such as video, typically means that the queuing delay
   will mostly be below the given delay target.  This is contrary to the
   case where large files are transmitted using LEDBAT congestion
   control and the queuing delay will stay close to the delay target.<a href="#section-3.1-3" class="pilcrow">¶</a></p>
</section>
</div>
<div id="sender-transmission-control">
<section id="section-3.2">
        <h3 id="name-sender-transmission-control">
<a href="#section-3.2" class="section-number selfRef">3.2. </a><a href="#name-sender-transmission-control" class="section-name selfRef">Sender Transmission Control</a>
        </h3>
<p id="section-3.2-1">The sender transmission control limits the output of data, given by
   the relation between the number of bytes in flight and the congestion
   window.  Packet pacing is used to mitigate issues with ACK
   compression that MAY cause increased jitter and/or packet loss in the
   media traffic.  Packet pacing limits the packet transmission rate
   given by the estimated link throughput.  Even if the send window
   allows for the transmission of a number of packets, these packets are
   not transmitted immediately; rather, they are transmitted in
   intervals given by the packet size and the estimated link throughput.<a href="#section-3.2-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="media-rate-control">
<section id="section-3.3">
        <h3 id="name-media-rate-control">
<a href="#section-3.3" class="section-number selfRef">3.3. </a><a href="#name-media-rate-control" class="section-name selfRef">Media Rate Control</a>
        </h3>
<p id="section-3.3-1">The media rate control serves to adjust the media bitrate to ramp up
   quickly enough to get a fair share of the system resources when link
   throughput increases.<a href="#section-3.3-1" class="pilcrow">¶</a></p>
<p id="section-3.3-2">The reaction to reduced throughput MUST be prompt in order to avoid
   getting too much data queued in the RTP packet queue(s) in the
   sender.  The media bitrate is decreased if the RTP queue size exceeds
   a threshold.<a href="#section-3.3-2" class="pilcrow">¶</a></p>
<p id="section-3.3-3">In cases where the sender's frame queues increase rapidly, such as in
   the case of a Radio Access Type (RAT) handover, the SCReAM sender MAY
   implement additional actions, such as discarding of encoded media
   frames or frame skipping in order to ensure that the RTP queues are
   drained quickly.  Frame skipping results in the frame rate being
   temporarily reduced.  Which method to use is a design choice and is
   outside the scope of this algorithm description.<a href="#section-3.3-3" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="detailed-description-of-scream">
<section id="section-4">
      <h2 id="name-detailed-description-of-scr">
<a href="#section-4" class="section-number selfRef">4. </a><a href="#name-detailed-description-of-scr" class="section-name selfRef">Detailed Description of SCReAM</a>
      </h2>
<div id="scream-sender">
<section id="section-4.1">
        <h3 id="name-scream-sender">
<a href="#section-4.1" class="section-number selfRef">4.1. </a><a href="#name-scream-sender" class="section-name selfRef">SCReAM Sender</a>
        </h3>
<p id="section-4.1-1">This section describes the sender-side algorithm in more detail.  It
   is split between the network congestion control, sender transmission
   control, and media rate control.<a href="#section-4.1-1" class="pilcrow">¶</a></p>
<p id="section-4.1-2">A SCReAM sender implements media rate control and an RTP queue for
   each media type or source, where RTP packets containing encoded media
   frames are temporarily stored for transmission.  Figure 1 shows the
   details when a single media source (or stream) is used.  A
   transmission scheduler (not shown in the figure) is added to support
   multiple streams.  The transmission scheduler can enforce differing
   priorities between the streams and act like a coupled congestion
   controller for multiple flows.  Support for multiple streams is
   implemented in <span>[<a href="#SCReAM-CPP-implementation" class="cite xref">SCReAM-CPP-implementation</a>]</span>.<a href="#section-4.1-2" class="pilcrow">¶</a></p>
<p id="section-4.1-3">Media frames are encoded and forwarded to the RTP queue (1) in
   Figure 1.  The media rate adaptation adapts to the size of the RTP
   queue (2) and provides a target rate for the media encoder (3).  The
   RTP packets are picked from the RTP queue (4), for multiple flows
   from each RTP queue based on some defined priority order or simply in
   a round-robin fashion, by the sender transmission controller.  The
   sender transmission controller (in case of multiple flows a
   transmission scheduler) sends the RTP packets to the UDP socket (5).
   In the general case, all media SHOULD go through the sender
   transmission controller and is limited so that the number of bytes in
   flight is less than the congestion window.  RTCP packets are received
   (6) and the information about the bytes in flight and congestion
   window is exchanged between the network congestion control and the
   sender transmission control (7).<a href="#section-4.1-3" class="pilcrow">¶</a></p>
<div id="constants-and-parameter-values">
<section id="section-4.1.1">
          <h4 id="name-constants-and-parameter-val">
<a href="#section-4.1.1" class="section-number selfRef">4.1.1. </a><a href="#name-constants-and-parameter-val" class="section-name selfRef">Constants and Parameter Values</a>
          </h4>
<p id="section-4.1.1-1">Constants and state variables are listed in this section.  Temporary
   variables are not listed; instead, they are appended with '_t' in the
   pseudocode to indicate their local scope.<a href="#section-4.1.1-1" class="pilcrow">¶</a></p>
<div id="constants">
<section id="section-4.1.1.1">
            <h5 id="name-constants">
<a href="#section-4.1.1.1" class="section-number selfRef">4.1.1.1. </a><a href="#name-constants" class="section-name selfRef">Constants</a>
            </h5>
<p id="section-4.1.1.1-1">The RECOMMENDED values, within parentheses "()", for the constants
   are deduced from experiments.<a href="#section-4.1.1.1-1" class="pilcrow">¶</a></p>
<span class="break"></span><dl class="dlParallel" id="section-4.1.1.1-2">
              <dt id="section-4.1.1.1-2.1">QDELAY_TARGET_LO (0.1 s):</dt>
              <dd style="margin-left: 1.5em" id="section-4.1.1.1-2.2">
                <p id="section-4.1.1.1-2.2.1">Target value for the minimum qdelay.<a href="#section-4.1.1.1-2.2.1" class="pilcrow">¶</a></p>
</dd>
              <dd class="break"></dd>
<dt id="section-4.1.1.1-2.3">QDELAY_TARGET_HI (0.4 s):</dt>
              <dd style="margin-left: 1.5em" id="section-4.1.1.1-2.4">
                <p id="section-4.1.1.1-2.4.1">Target value for the maximum qdelay.  This parameter provides an
upper limit to how much the target qdelay (qdelay_target) can be
increased in order to cope with competing loss-based flows.
However, the target qdelay does not have to be initialized to this
high value, as it would increase end-to-end delay and also make the
rate control and congestion control loops sluggish.<a href="#section-4.1.1.1-2.4.1" class="pilcrow">¶</a></p>
</dd>
              <dd class="break"></dd>
<dt id="section-4.1.1.1-2.5">QDELAY_WEIGHT (0.1):</dt>
              <dd style="margin-left: 1.5em" id="section-4.1.1.1-2.6">
                <p id="section-4.1.1.1-2.6.1">Averaging factor for qdelay_fraction_avg.<a href="#section-4.1.1.1-2.6.1" class="pilcrow">¶</a></p>
</dd>
              <dd class="break"></dd>
<dt id="section-4.1.1.1-2.7">QDELAY_TREND_TH (0.2):</dt>
              <dd style="margin-left: 1.5em" id="section-4.1.1.1-2.8">
                <p id="section-4.1.1.1-2.8.1">Threshold for the detection of incipient congestion.<a href="#section-4.1.1.1-2.8.1" class="pilcrow">¶</a></p>
</dd>
              <dd class="break"></dd>
<dt id="section-4.1.1.1-2.9">MIN_CWND (3000 bytes):</dt>
              <dd style="margin-left: 1.5em" id="section-4.1.1.1-2.10">
                <p id="section-4.1.1.1-2.10.1">Minimum congestion window.<a href="#section-4.1.1.1-2.10.1" class="pilcrow">¶</a></p>
</dd>
              <dd class="break"></dd>
<dt id="section-4.1.1.1-2.11">MAX_BYTES_IN_FLIGHT_HEAD_ROOM (1.1):</dt>
              <dd style="margin-left: 1.5em" id="section-4.1.1.1-2.12">
                <p id="section-4.1.1.1-2.12.1">Headroom for the limitation of CWND.<a href="#section-4.1.1.1-2.12.1" class="pilcrow">¶</a></p>
</dd>
              <dd class="break"></dd>
<dt id="section-4.1.1.1-2.13">GAIN (1.0):</dt>
              <dd style="margin-left: 1.5em" id="section-4.1.1.1-2.14">
                <p id="section-4.1.1.1-2.14.1">Gain factor for congestion window adjustment.<a href="#section-4.1.1.1-2.14.1" class="pilcrow">¶</a></p>
</dd>
              <dd class="break"></dd>
<dt id="section-4.1.1.1-2.15">BETA_LOSS (0.8):</dt>
              <dd style="margin-left: 1.5em" id="section-4.1.1.1-2.16">
                <p id="section-4.1.1.1-2.16.1">CWND scale factor due to loss event.<a href="#section-4.1.1.1-2.16.1" class="pilcrow">¶</a></p>
</dd>
              <dd class="break"></dd>
<dt id="section-4.1.1.1-2.17">BETA_ECN (0.9):</dt>
              <dd style="margin-left: 1.5em" id="section-4.1.1.1-2.18">
                <p id="section-4.1.1.1-2.18.1">CWND scale factor due to ECN event.<a href="#section-4.1.1.1-2.18.1" class="pilcrow">¶</a></p>
</dd>
              <dd class="break"></dd>
<dt id="section-4.1.1.1-2.19">BETA_R (0.9):</dt>
              <dd style="margin-left: 1.5em" id="section-4.1.1.1-2.20">
                <p id="section-4.1.1.1-2.20.1">Scale factor for target rate due to loss event.<a href="#section-4.1.1.1-2.20.1" class="pilcrow">¶</a></p>
</dd>
              <dd class="break"></dd>
<dt id="section-4.1.1.1-2.21">MSS (1000 byte):</dt>
              <dd style="margin-left: 1.5em" id="section-4.1.1.1-2.22">
                <p id="section-4.1.1.1-2.22.1">Maximum segment size = Max RTP packet size.<a href="#section-4.1.1.1-2.22.1" class="pilcrow">¶</a></p>
</dd>
              <dd class="break"></dd>
<dt id="section-4.1.1.1-2.23">RATE_ADJUST_INTERVAL (0.2 s):</dt>
              <dd style="margin-left: 1.5em" id="section-4.1.1.1-2.24">
                <p id="section-4.1.1.1-2.24.1">Interval between media bitrate adjustments.<a href="#section-4.1.1.1-2.24.1" class="pilcrow">¶</a></p>
</dd>
              <dd class="break"></dd>
<dt id="section-4.1.1.1-2.25">TARGET_BITRATE_MIN:</dt>
              <dd style="margin-left: 1.5em" id="section-4.1.1.1-2.26">
                <p id="section-4.1.1.1-2.26.1">Minimum target bitrate in bps (bits per second).<a href="#section-4.1.1.1-2.26.1" class="pilcrow">¶</a></p>
</dd>
              <dd class="break"></dd>
<dt id="section-4.1.1.1-2.27">TARGET_BITRATE_MAX:</dt>
              <dd style="margin-left: 1.5em" id="section-4.1.1.1-2.28">
                <p id="section-4.1.1.1-2.28.1">Maximum target bitrate in bps.<a href="#section-4.1.1.1-2.28.1" class="pilcrow">¶</a></p>
</dd>
              <dd class="break"></dd>
<dt id="section-4.1.1.1-2.29">RAMP_UP_SPEED (200000 bps/s):</dt>
              <dd style="margin-left: 1.5em" id="section-4.1.1.1-2.30">
                <p id="section-4.1.1.1-2.30.1">Maximum allowed rate increase speed.<a href="#section-4.1.1.1-2.30.1" class="pilcrow">¶</a></p>
</dd>
              <dd class="break"></dd>
<dt id="section-4.1.1.1-2.31">PRE_CONGESTION_GUARD  (0.0..1.0):</dt>
              <dd style="margin-left: 1.5em" id="section-4.1.1.1-2.32">
                <p id="section-4.1.1.1-2.32.1">Guard factor against early congestion onset.  A higher value gives
less jitter, possibly at the expense of a lower link utilization.
This value MAY be subject to tuning depending on e.g., media coder
characteristics.  Experiments with H264 and VP8 indicate that 0.1
is a suitable value.  See <span>[<a href="#SCReAM-CPP-implementation" class="cite xref">SCReAM-CPP-implementation</a>]</span> and
<span>[<a href="#SCReAM-implementation-experience" class="cite xref">SCReAM-implementation-experience</a>]</span> for evaluation of a real
implementation.<a href="#section-4.1.1.1-2.32.1" class="pilcrow">¶</a></p>
</dd>
              <dd class="break"></dd>
<dt id="section-4.1.1.1-2.33">TX_QUEUE_SIZE_FACTOR (0.0..2.0):</dt>
              <dd style="margin-left: 1.5em" id="section-4.1.1.1-2.34">
                <p id="section-4.1.1.1-2.34.1">Guard factor against RTP queue buildup.  This value MAY be subject
to tuning depending on, e.g., media coder characteristics.
Experiments with H264 and VP8 indicate that 1.0 is a suitable
value.  See <span>[<a href="#SCReAM-CPP-implementation" class="cite xref">SCReAM-CPP-implementation</a>]</span> and
<span>[<a href="#SCReAM-implementation-experience" class="cite xref">SCReAM-implementation-experience</a>]</span> for evaluation of a real
implementation.<a href="#section-4.1.1.1-2.34.1" class="pilcrow">¶</a></p>
</dd>
            <dd class="break"></dd>
</dl>
<p id="section-4.1.1.1-3">RTP_QDELAY_TH (0.02 s):
     : RTP queue delay threshold for a target rate
      reduction.<a href="#section-4.1.1.1-3" class="pilcrow">¶</a></p>
<p id="section-4.1.1.1-4">TARGET_RATE_SCALE_RTP_QDELAY (0.95):
     : Scale factor for target rate
       when RTP qdelay threshold exceeds RTP_QDELAY_TH.<a href="#section-4.1.1.1-4" class="pilcrow">¶</a></p>
<p id="section-4.1.1.1-5">QDELAY_TREND_LO (0.2):
     : Threshold value for qdelay_trend.<a href="#section-4.1.1.1-5" class="pilcrow">¶</a></p>
<p id="section-4.1.1.1-6">T_RESUME_FAST_INCREASE (5 s):
     : Time span until fast increase mode can
     be resumed, given that the qdelay_trend is below QDELAY_TREND_LO.<a href="#section-4.1.1.1-6" class="pilcrow">¶</a></p>
<p id="section-4.1.1.1-7">RATE_PACE_MIN (50000 bps):
     : Minimum pacing rate.<a href="#section-4.1.1.1-7" class="pilcrow">¶</a></p>
</section>
</div>
<div id="state-variables">
<section id="section-4.1.1.2">
            <h5 id="name-state-variables">
<a href="#section-4.1.1.2" class="section-number selfRef">4.1.1.2. </a><a href="#name-state-variables" class="section-name selfRef">State Variables</a>
            </h5>
<p id="section-4.1.1.2-1">The values within parentheses "()" indicate initial values.<a href="#section-4.1.1.2-1" class="pilcrow">¶</a></p>
<p id="section-4.1.1.2-2">qdelay_target (QDELAY_TARGET_LO):
     : qdelay target, a variable qdelay target is introduced to manage
       cases where a fixed qdelay target would otherwise starve the RMCAT
       flow under such circumstances (e.g., FTP competes for the bandwidth
       over the same bottleneck).  The qdelay target is allowed to vary
       between QDELAY_TARGET_LO and QDELAY_TARGET_HI.<a href="#section-4.1.1.2-2" class="pilcrow">¶</a></p>
<p id="section-4.1.1.2-3">qdelay_fraction_avg (0.0):
     : Fractional qdelay filtered by the Exponentially Weighted Moving
       Average (EWMA).<a href="#section-4.1.1.2-3" class="pilcrow">¶</a></p>
<p id="section-4.1.1.2-4">qdelay_fraction_hist[20] ({0,..,0}):
     : Vector of the last 20 fractional qdelay samples.<a href="#section-4.1.1.2-4" class="pilcrow">¶</a></p>
<p id="section-4.1.1.2-5">qdelay_trend (0.0):
     : qdelay trend; indicates incipient congestion.<a href="#section-4.1.1.2-5" class="pilcrow">¶</a></p>
<p id="section-4.1.1.2-6">qdelay_trend_mem (0.0):
     : Low-pass filtered version of qdelay_trend.<a href="#section-4.1.1.2-6" class="pilcrow">¶</a></p>
<p id="section-4.1.1.2-7">qdelay_norm_hist[100] ({0,..,0}):
     : Vector of the last 100 normalized qdelay samples.<a href="#section-4.1.1.2-7" class="pilcrow">¶</a></p>
<p id="section-4.1.1.2-8">in_fast_increase (true):
     : True if in fast increase mode.<a href="#section-4.1.1.2-8" class="pilcrow">¶</a></p>
<p id="section-4.1.1.2-9">cwnd (MIN_CWND):
     : Congestion window.<a href="#section-4.1.1.2-9" class="pilcrow">¶</a></p>
<p id="section-4.1.1.2-10">bytes_newly_acked (0):
     : The number of bytes that was acknowledged with the last received
       acknowledgement, i.e., bytes acknowledged since the last CWND
       update.<a href="#section-4.1.1.2-10" class="pilcrow">¶</a></p>
<p id="section-4.1.1.2-11">max_bytes_in_flight (0):
     : The maximum number of bytes in flight over a sliding time window,
       i.e., transmitted but not yet acknowledged bytes.<a href="#section-4.1.1.2-11" class="pilcrow">¶</a></p>
<p id="section-4.1.1.2-12">send_wnd (0):
     : Upper limit to how many bytes can currently be transmitted.
       Updated when cwnd is updated and when RTP packet is transmitted.<a href="#section-4.1.1.2-12" class="pilcrow">¶</a></p>
<p id="section-4.1.1.2-13">target_bitrate (0 bps):
     : Media target bitrate.<a href="#section-4.1.1.2-13" class="pilcrow">¶</a></p>
<p id="section-4.1.1.2-14">target_bitrate_last_max (1 bps):
     : Inflection point of the media target bitrate, i.e., the last known
       highest target_bitrate.  Used to limit bitrate increase speed close
       to the last known congestion point.<a href="#section-4.1.1.2-14" class="pilcrow">¶</a></p>
<p id="section-4.1.1.2-15">rate_transmit (0.0 bps):
     : Measured transmit bitrate.<a href="#section-4.1.1.2-15" class="pilcrow">¶</a></p>
<p id="section-4.1.1.2-16">rate_ack (0.0 bps):
     : Measured throughput based on received acknowledgements.<a href="#section-4.1.1.2-16" class="pilcrow">¶</a></p>
<p id="section-4.1.1.2-17">rate_media (0.0 bps):
     : Measured bitrate from the media encoder.<a href="#section-4.1.1.2-17" class="pilcrow">¶</a></p>
<p id="section-4.1.1.2-18">rate_media_median (0.0 bps):
     : Median value of rate_media, computed over more than 10 s.<a href="#section-4.1.1.2-18" class="pilcrow">¶</a></p>
<p id="section-4.1.1.2-19">s_rtt (0.0s):
     : Smoothed RTT (in seconds), computed with a similar method to that
       described in <span>[<a href="#RFC6298" class="cite xref">RFC6298</a>]</span>.<a href="#section-4.1.1.2-19" class="pilcrow">¶</a></p>
<p id="section-4.1.1.2-20">rtp_queue_size (0 bits):
     : Sum of the sizes of RTP packets in queue.<a href="#section-4.1.1.2-20" class="pilcrow">¶</a></p>
<p id="section-4.1.1.2-21">rtp_size (0 byte):
     : Size of the last transmitted RTP packet.<a href="#section-4.1.1.2-21" class="pilcrow">¶</a></p>
<p id="section-4.1.1.2-22">loss_event_rate (0.0):
     : The estimated fraction of RTTs with lost packets detected.<a href="#section-4.1.1.2-22" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="network-congestion-control-1">
<section id="section-4.1.2">
          <h4 id="name-network-congestion-control-2">
<a href="#section-4.1.2" class="section-number selfRef">4.1.2. </a><a href="#name-network-congestion-control-2" class="section-name selfRef">Network Congestion Control</a>
          </h4>
<p id="section-4.1.2-1">This section explains the network congestion control, which performs
   two main functions:<a href="#section-4.1.2-1" class="pilcrow">¶</a></p>
<p id="section-4.1.2-2">o  Computation of congestion window at the sender: This gives an
      upper limit to the number of bytes in flight.<a href="#section-4.1.2-2" class="pilcrow">¶</a></p>
<p id="section-4.1.2-3">o  Calculation of send window at the sender: RTP packets are
      transmitted if allowed by the relation between the number of bytes
      in flight and the congestion window.  This is controlled by the
      send window.<a href="#section-4.1.2-3" class="pilcrow">¶</a></p>
<p id="section-4.1.2-4">SCReAM is a window-based and byte-oriented congestion control
   protocol, where the number of bytes transmitted is inferred from the
   size of the transmitted RTP packets.  Thus, a list of transmitted RTP
   packets and their respective transmission times (wall-clock time)
   MUST be kept for further calculation.<a href="#section-4.1.2-4" class="pilcrow">¶</a></p>
<p id="section-4.1.2-5">The number of bytes in flight (bytes_in_flight) is computed as the
   sum of the sizes of the RTP packets ranging from the RTP packet most
   recently transmitted, down to but not including the acknowledged
   packet with the highest sequence number.  This can be translated to
   the difference between the highest transmitted byte sequence number
   and the highest acknowledged byte sequence number.  As an example: If
   an RTP packet with sequence number SN is transmitted and the last
   acknowledgement indicates SN-5 as the highest received sequence
   number, then bytes_in_flight is computed as the sum of the size of
   RTP packets with sequence number SN-4, SN-3, SN-2, SN-1, and SN.  It
   does not matter if, for instance, the packet with sequence number
   SN-3 was lost -- the size of RTP packet with sequence number SN-3
   will still be considered in the computation of bytes_in_flight.<a href="#section-4.1.2-5" class="pilcrow">¶</a></p>
<p id="section-4.1.2-6">Furthermore, a variable bytes_newly_acked is incremented with a value
   corresponding to how much the highest sequence number has increased
   since the last feedback.  As an example: If the previous
   acknowledgement indicated the highest sequence number N and the new
   acknowledgement indicated N+3, then bytes_newly_acked is incremented
   by a value equal to the sum of the sizes of RTP packets with sequence
   number N+1, N+2, and N+3.  Packets that are lost are also included,
   which means that even though, e.g., packet N+2 was lost, its size is
   still included in the update of bytes_newly_acked.  The
   bytes_newly_acked variable is reset to zero after a CWND update.<a href="#section-4.1.2-6" class="pilcrow">¶</a></p>
<p id="section-4.1.2-7">The feedback from the receiver is assumed to consist of the following
   elements.<a href="#section-4.1.2-7" class="pilcrow">¶</a></p>
<p id="section-4.1.2-8">o  A list of received RTP packets' sequence numbers.<a href="#section-4.1.2-8" class="pilcrow">¶</a></p>
<p id="section-4.1.2-9">o  The wall-clock timestamp corresponding to the received RTP packet
      with the highest sequence number.<a href="#section-4.1.2-9" class="pilcrow">¶</a></p>
<p id="section-4.1.2-10">o  The accumulated number of ECN-CE-marked packets (n_ECN).  Here,
      "CE" refers to "Congestion Experienced".<a href="#section-4.1.2-10" class="pilcrow">¶</a></p>
<p id="section-4.1.2-11">When the sender receives RTCP feedback, the qdelay is calculated as
   outlined in <span>[<a href="#RFC6817" class="cite xref">RFC6817</a>]</span>.  A qdelay sample is obtained for each received
   acknowledgement.  No smoothing of the qdelay is performed; however,
   some smoothing occurs anyway because the CWND computation is a low-
   pass filter function.  A number of variables are updated as
   illustrated by the pseudocode below; temporary variables are appended
   with '_t'.  As mentioned in Section 6, calculation of the proper
   congestion window and media bitrate may benefit from additional
   optimizations to handle very high and very low bitrates, and from
   additional damping to handle periodic packet bursts.  Some such
   optimizations are implemented in <span>[<a href="#SCReAM-CPP-implementation" class="cite xref">SCReAM-CPP-implementation</a>]</span>, but
   they do not form part of the specification of SCReAM at this time.<a href="#section-4.1.2-11" class="pilcrow">¶</a></p>
<div class="sourcecode" id="section-4.1.2-12">
<pre>&lt;CODE BEGINS&gt;
 update_variables(qdelay):
   qdelay_fraction_t = qdelay / qdelay_target
   # Calculate moving average
   qdelay_fraction_avg = (1 - QDELAY_WEIGHT) * qdelay_fraction_avg +
      QDELAY_WEIGHT * qdelay_fraction_t
   update_qdelay_fraction_hist(qdelay_fraction_t)
   # Compute the average of the values in qdelay_fraction_hist
   avg_t = average(qdelay_fraction_hist)
   # R is an autocorrelation function of qdelay_fraction_hist,
   #  with the mean (DC component) removed, at lag K
   # The subtraction of the scalar avg_t from
   #  qdelay_fraction_hist is performed element-wise
   a_t = R(qdelay_fraction_hist-avg_t, 1) /
         R(qdelay_fraction_hist-avg_t, 0)
   # Calculate qdelay trend
   qdelay_trend = min(1.0, max(0.0, a_t * qdelay_fraction_avg))
   # Calculate a 'peak-hold' qdelay_trend; this gives a memory
   #  of congestion in the past
   qdelay_trend_mem = max(0.99 * qdelay_trend_mem, qdelay_trend)

&lt;CODE ENDS&gt;</pre><a href="#section-4.1.2-12" class="pilcrow">¶</a>
</div>
<p id="section-4.1.2-13">The qdelay fraction is sampled every 50 ms, and the last 20 samples
   are stored in a vector (qdelay_fraction_hist).  This vector is used
   in the computation of a qdelay trend that gives a value between 0.0
   and 1.0 depending on the estimated congestion level.  The prediction
   coefficient 'a_t' has positive values if qdelay shows an increasing
   or decreasing trend; thus, an indication of congestion is obtained
   before the qdelay target is reached.  As a side effect, if qdelay
   decreases, it's taken as a sign of congestion; however, experiments
   have shown that this is beneficial, as increasing or decreasing queue
   delay is an indication that the transmit rate is very close to the
   path capacity.<a href="#section-4.1.2-13" class="pilcrow">¶</a></p>
<p id="section-4.1.2-14">The autocorrelation function 'R' is defined as follows.  Let x be a
   vector constituting N values, the biased autocorrelation function for
   a given lag=k for the vector x is given by.<a href="#section-4.1.2-14" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-4.1.2-15">
<pre>
             n=N-k
     R(x,k) = SUM x(n) * x(n + k)
             n=1
</pre><a href="#section-4.1.2-15" class="pilcrow">¶</a>
</div>
<p id="section-4.1.2-16">The prediction coefficient is further multiplied with
   qdelay_fraction_avg to reduce sensitivity to increasing qdelay when
   it is very small.  The 50 ms sampling is a simplification that could
   have the effect that the same qdelay is sampled several times;
   however, this does not pose any problem, as the vector is only used
   to determine if the qdelay is increasing or decreasing.  The
   qdelay_trend is utilized in the media rate control to indicate
   incipient congestion and to determine when to exit from fast increase
   mode. qdelay_trend_mem is used to enforce a less aggressive rate
   increase after congestion events.  The function
   update_qdelay_fraction_hist(..) removes the oldest element and adds
   the latest qdelay_fraction element to the qdelay_fraction_hist
   vector.<a href="#section-4.1.2-16" class="pilcrow">¶</a></p>
<div id="reaction-to-packet-loss-and-ecn">
<section id="section-4.1.2.1">
            <h5 id="name-reaction-to-packet-loss-and">
<a href="#section-4.1.2.1" class="section-number selfRef">4.1.2.1. </a><a href="#name-reaction-to-packet-loss-and" class="section-name selfRef">Reaction to Packet Loss and ECN</a>
            </h5>
<p id="section-4.1.2.1-1">A loss event is indicated if one or more RTP packets are declared
   missing.  The loss detection is described in Section 4.1.2.4.  Once a
   loss event is detected, further detected lost RTP packets SHOULD be
   ignored for a full smoothed round-trip time; the intention is to
   limit the congestion window decrease to at most once per round trip.<a href="#section-4.1.2.1-1" class="pilcrow">¶</a></p>
<p id="section-4.1.2.1-2">The congestion window back-off due to loss events is deliberately a
   bit less than is the case with TCP Reno, for example.  TCP is
   generally used to transmit whole files; the file is then like a
   source with an infinite bitrate until the whole file has been
   transmitted.  SCReAM, on the other hand, has a source whose rate is
   limited to a value close to the available transmit rate and often
   below that value; the effect is that SCReAM has less opportunity to
   grab free capacity than a TCP-based file transfer.  To compensate for
   this, it is RECOMMENDED to let SCReAM reduce the congestion window
   less than what is the case with TCP when loss events occur.<a href="#section-4.1.2.1-2" class="pilcrow">¶</a></p>
<p id="section-4.1.2.1-3">An ECN event is detected if the n_ECN counter in the feedback report
   has increased since the previous received feedback.  Once an ECN
   event is detected, the n_ECN counter is ignored for a full smoothed
   round-trip time; the intention is to limit the congestion window
   decrease to at most once per round trip.  The congestion window back-
   off due to an ECN event MAY be smaller than if a loss event occurs.
   This is in line with the idea outlined in <span>[<a href="#RFC8511" class="cite xref">RFC8511</a>]</span> to enable ECN
   marking thresholds lower than the corresponding packet drop
   thresholds.<a href="#section-4.1.2.1-3" class="pilcrow">¶</a></p>
</section>
</div>
<div id="congestion-window-update">
<section id="section-4.1.2.2">
            <h5 id="name-congestion-window-update">
<a href="#section-4.1.2.2" class="section-number selfRef">4.1.2.2. </a><a href="#name-congestion-window-update" class="section-name selfRef">Congestion Window Update</a>
            </h5>
<p id="section-4.1.2.2-1">The update of the congestion window depends on if loss, ECN-marking,
   or neither of the two occurs.  The pseudocode below describes the
   actions for each case.<a href="#section-4.1.2.2-1" class="pilcrow">¶</a></p>
<div class="sourcecode" id="section-4.1.2.2-2">
<pre>&lt;CODE BEGINS&gt;
     on congestion event(qdelay):
       # Either loss or ECN mark is detected
       in_fast_increase = false
       if (is loss)
         # Loss is detected
         cwnd = max(MIN_CWND, cwnd * BETA_LOSS)
       else
         # No loss, so it is then an ECN mark
         cwnd = max(MIN_CWND, cwnd * BETA_ECN)
       end
       adjust_qdelay_target(qdelay) #compensating for competing flows
       calculate_send_window(qdelay, qdelay_target)

     # When no congestion event
     on acknowledgement(qdelay):
       update_bytes_newly_acked()
       update_cwnd(bytes_newly_acked)
       adjust_qdelay_target(qdelay) # compensating for competing flows
       calculate_send_window(qdelay, qdelay_target)
       check_to_resume_fast_increase()

&lt;CODE ENDS&gt;</pre><a href="#section-4.1.2.2-2" class="pilcrow">¶</a>
</div>
<p id="section-4.1.2.2-3">The methods are described in detail below.<a href="#section-4.1.2.2-3" class="pilcrow">¶</a></p>
<p id="section-4.1.2.2-4">The congestion window update is based on qdelay, except for the
   occurrence of loss events (one or more lost RTP packets in one RTT)
   or ECN events, which were described earlier.<a href="#section-4.1.2.2-4" class="pilcrow">¶</a></p>
<p id="section-4.1.2.2-5">Pseudocode for the update of the congestion window is found below.<a href="#section-4.1.2.2-5" class="pilcrow">¶</a></p>
<div class="sourcecode" id="section-4.1.2.2-6">
<pre>&lt;CODE BEGINS&gt;
   update_cwnd(bytes_newly_acked):
     # In fast increase mode?
     if (in_fast_increase)
       if (qdelay_trend &gt;= QDELAY_TREND_TH)
         # Incipient congestion detected; exit fast increase mode
         in_fast_increase = false
       else
         # No congestion yet; increase cwnd if it
         #  is sufficiently used
         # Additional slack of bytes_newly_acked is
         #  added to ensure that CWND growth occurs
         #  even when feedback is sparse
         if (bytes_in_flight * 1.5 + bytes_newly_acked &gt; cwnd)
           cwnd = cwnd + bytes_newly_acked
         end
         return
       end
     end

     # Not in fast increase mode
     # off_target calculated as with LEDBAT
     off_target_t = (qdelay_target - qdelay) / qdelay_target

     gain_t = GAIN
     # Adjust congestion window
     cwnd_delta_t =
       gain_t * off_target_t * bytes_newly_acked * MSS / cwnd
     if (off_target_t &gt; 0 &amp;&amp;
         bytes_in_flight * 1.25 + bytes_newly_acked &lt;= cwnd)
       # No cwnd increase if window is underutilized
       # Additional slack of bytes_newly_acked is
       #  added to ensure that CWND growth occurs
       #  even when feedback is sparse
       cwnd_delta_t = 0;
     end

     # Apply delta
     cwnd += cwnd_delta_t
     # limit cwnd to the maximum number of bytes in flight
     cwnd = min(cwnd, max_bytes_in_flight *
                MAX_BYTES_IN_FLIGHT_HEAD_ROOM)
     cwnd = max(cwnd, MIN_CWND)


&lt;CODE ENDS&gt;</pre><a href="#section-4.1.2.2-6" class="pilcrow">¶</a>
</div>
<p id="section-4.1.2.2-7">CWND is updated differently depending on whether or not the
   congestion control is in fast increase mode, as controlled by the
   variable in_fast_increase.<a href="#section-4.1.2.2-7" class="pilcrow">¶</a></p>
<p id="section-4.1.2.2-8">When in fast increase mode, the congestion window is increased with
   the number of newly acknowledged bytes as long as the window is
   sufficiently used.  Sparse feedback can potentially limit congestion
   window growth; therefore, additional slack is added, given by the
   number of newly acknowledged bytes.<a href="#section-4.1.2.2-8" class="pilcrow">¶</a></p>
<p id="section-4.1.2.2-9">The congestion window growth when in_fast_increase is false is
   dictated by the relation between qdelay and qdelay_target; congestion
   window growth is limited if the window is not used sufficiently.<a href="#section-4.1.2.2-9" class="pilcrow">¶</a></p>
<p id="section-4.1.2.2-10">SCReAM calculates the GAIN in a similar way to what is specified in
   <span>[<a href="#RFC6817" class="cite xref">RFC6817</a>]</span>.  However, <span>[<a href="#RFC6817" class="cite xref">RFC6817</a>]</span> specifies that the CWND increase is
   limited by an additional function controlled by a constant
   ALLOWED_INCREASE.  This additional limitation is removed in this
   specification.<a href="#section-4.1.2.2-10" class="pilcrow">¶</a></p>
<p id="section-4.1.2.2-11">Further, the CWND is limited by max_bytes_in_flight and MIN_CWND.
   The limitation of the congestion window by the maximum number of
   bytes in flight over the last 5 seconds (max_bytes_in_flight) avoids
   possible overestimation of the throughput after, for example, idle
   periods.  An additional MAX_BYTES_IN_FLIGHT_HEAD_ROOM provides slack
   to allow for a certain amount of variability in the media coder
   output rate.<a href="#section-4.1.2.2-11" class="pilcrow">¶</a></p>
</section>
</div>
<div id="competing-flows-compensation">
<section id="section-4.1.2.3">
            <h5 id="name-competing-flows-compensatio">
<a href="#section-4.1.2.3" class="section-number selfRef">4.1.2.3. </a><a href="#name-competing-flows-compensatio" class="section-name selfRef">Competing Flows Compensation</a>
            </h5>
<p id="section-4.1.2.3-1">It is likely that a flow using the SCReAM algorithm will have to
   share congested bottlenecks with other flows that use a more
   aggressive congestion control algorithm (for example, large FTP flows
   using loss-based congestion control).  The worst condition occurs
   when the bottleneck queues are of tail-drop type with a large buffer
   size.  SCReAM takes care of such situations by adjusting the
   qdelay_target when loss-based flows are detected, as shown in the
   pseudocode below.<a href="#section-4.1.2.3-1" class="pilcrow">¶</a></p>
<div class="sourcecode" id="section-4.1.2.3-2">
<pre>&lt;CODE BEGINS&gt;
     adjust_qdelay_target(qdelay)
       qdelay_norm_t = qdelay / QDELAY_TARGET_LOW
       update_qdelay_norm_history(qdelay_norm_t)
       # Compute variance
       qdelay_norm_var_t = VARIANCE(qdelay_norm_history(200))
       # Compensation for competing traffic
       # Compute average
       qdelay_norm_avg_t = AVERAGE(qdelay_norm_history(50))
       # Compute upper limit to target delay
       new_target_t = qdelay_norm_avg_t + sqrt(qdelay_norm_var_t)
       new_target_t *= QDELAY_TARGET_LO
       if (loss_event_rate &gt; 0.002)
         # Packet losses detected
         qdelay_target = 1.5 * new_target_t
       else
         if (qdelay_norm_var_t &lt; 0.2)
           # Reasonably safe to set target qdelay
           qdelay_target = new_target_t
         else
           # Check if target delay can be reduced; this helps prevent
           #  the target delay from being locked to high values forever
           if (new_target_t &lt; QDELAY_TARGET_LO)
             # Decrease target delay quickly, as measured queuing
             #  delay is lower than target
             qdelay_target = max(qdelay_target * 0.5, new_target_t)
           else
             # Decrease target delay slowly
             qdelay_target *= 0.9
           end
         end
       end

       # Apply limits
       qdelay_target = min(QDELAY_TARGET_HI, qdelay_target)
       qdelay_target = max(QDELAY_TARGET_LO, qdelay_target)

&lt;CODE ENDS&gt;</pre><a href="#section-4.1.2.3-2" class="pilcrow">¶</a>
</div>
<p id="section-4.1.2.3-3">Two temporary variables are calculated. qdelay_norm_avg_t is the
   long-term average queue delay, qdelay_norm_var_t is the long-term
   variance of the queue delay.  A high qdelay_norm_var_t indicates that
   the queue delay changes; this can be an indication that bottleneck
   bandwidth is reduced or that a competing flow has just entered.
   Thus, it indicates that it is not safe to adjust the queue delay
   target.<a href="#section-4.1.2.3-3" class="pilcrow">¶</a></p>
<p id="section-4.1.2.3-4">A low qdelay_norm_var_t indicates that the queue delay is relatively
   stable.  The reason could be that the queue delay is low, but it
   could also be that a competing flow is causing the bottleneck to
   reach the point that packet losses start to occur, in which case the
   queue delay will stay relatively high for a longer time.<a href="#section-4.1.2.3-4" class="pilcrow">¶</a></p>
<p id="section-4.1.2.3-5">The queue delay target is allowed to be increased if either the loss
   event rate is above a given threshold or qdelay_norm_var_t is low.
   Both these conditions indicate that a competing flow may be present.
   In all other cases, the queue delay target is decreased.<a href="#section-4.1.2.3-5" class="pilcrow">¶</a></p>
<p id="section-4.1.2.3-6">The function that adjusts the qdelay_target is simple and could
   produce false positives and false negatives.  The case that self-
   inflicted congestion by the SCReAM algorithm may be falsely
   interpreted as the presence of competing loss-based FTP flows is a
   false positive.  The opposite case -- where the algorithm fails to
   detect the presence of a competing FTP flow -- is a false negative.<a href="#section-4.1.2.3-6" class="pilcrow">¶</a></p>
<p id="section-4.1.2.3-7">Extensive simulations have shown that the algorithm performs well in
   LTE test cases and that it also performs well in simple bandwidth-
   limited bottleneck test cases with competing FTP flows.  However, the
   potential failure of the algorithm cannot be completely ruled out.  A
   false positive (i.e., when self-inflicted congestion is mistakenly
   identified as competing flows) is especially problematic when it
   leads to increasing the target queue delay, which can cause the end-
   to-end delay to increase dramatically.<a href="#section-4.1.2.3-7" class="pilcrow">¶</a></p>
<p id="section-4.1.2.3-8">If it is deemed unlikely that competing flows occur over the same
   bottleneck, the algorithm described in this section MAY be turned
   off.  One such case is QoS-enabled bearers in 3GPP-based access such
   as LTE.  However, when sending over the Internet, often the network
   conditions are not known for sure, so in general it is not possible
   to make safe assumptions on how a network is used and whether or not
   competing flows share the same bottleneck.  Therefore, turning this
   algorithm off must be considered with caution, as it can lead to
   basically zero throughput if competing with loss-based traffic.<a href="#section-4.1.2.3-8" class="pilcrow">¶</a></p>
</section>
</div>
<div id="lost-packet-detection">
<section id="section-4.1.2.4">
            <h5 id="name-lost-packet-detection">
<a href="#section-4.1.2.4" class="section-number selfRef">4.1.2.4. </a><a href="#name-lost-packet-detection" class="section-name selfRef">Lost Packet Detection</a>
            </h5>
<p id="section-4.1.2.4-1">Lost packet detection is based on the received sequence number list.
   A reordering window SHOULD be applied to prevent packet reordering
   from triggering loss events.  The reordering window is specified as a
   time unit, similar to the ideas behind Recent ACKnowledgement (RACK)
   <span>[<a href="#RFC8985" class="cite xref">RFC8985</a>]</span>.  The computation of the reordering window is made possible by
   means of a lost flag in the list of transmitted RTP packets.  This
   flag is set if the received sequence number list indicates that the
   given RTP packet is missing.  If later feedback indicates that a
   previously lost marked packet was indeed received, then the
   reordering window is updated to reflect the reordering delay.  The
   reordering window is given by the difference in time between the
   event that the packet was marked as lost and the event that it was
   indicated as successfully received.  Loss is detected if a given RTP
   packet is not acknowledged within a time window (indicated by the
   reordering window) after an RTP packet with a higher sequence number
   was acknowledged.<a href="#section-4.1.2.4-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="send-window-calculation">
<section id="section-4.1.2.5">
            <h5 id="name-send-window-calculation">
<a href="#section-4.1.2.5" class="section-number selfRef">4.1.2.5. </a><a href="#name-send-window-calculation" class="section-name selfRef">Send Window Calculation</a>
            </h5>
<p id="section-4.1.2.5-1">The basic design principle behind packet transmission in SCReAM is to
   allow transmission only if the number of bytes in flight is less than
   the congestion window.  There are, however, two reasons why this
   strict rule will not work optimally:<a href="#section-4.1.2.5-1" class="pilcrow">¶</a></p>
<p id="section-4.1.2.5-2">o  Bitrate variations: Media sources such as video encoders generally
      produce frames whose size always vary to a larger or smaller
      extent.  The RTP queue absorbs the natural variations in frame
      sizes.  However, the RTP queue should be as short as possible to
      prevent the end-to-end delay from increasing.  To achieve that,
      the media rate control takes the RTP queue size into account when
      the target bitrate for the media is computed.  A strict 'send only
      when bytes in flight is less than the congestion window' rule can
      cause the RTP queue to grow simply because the send window is
      limited; in turn, this can cause the target bitrate to be pushed
      down.  The consequence is that the congestion window will not
      increase, or will increase very slowly, because the congestion
      window is only allowed to increase when there is a sufficient
      amount of data in flight.  The final effect is that the media
      bitrate increases very slowly or not at all.<a href="#section-4.1.2.5-2" class="pilcrow">¶</a></p>
<p id="section-4.1.2.5-3">o  Reverse (feedback) path congestion: Especially in transport over
      buffer-bloated networks, the one-way delay in the reverse
      direction can jump due to congestion.  The effect is that the
      acknowledgements are delayed, and the self-clocking is temporarily
      halted, even though the forward path is not congested.<a href="#section-4.1.2.5-3" class="pilcrow">¶</a></p>
<p id="section-4.1.2.5-4">The send window is adjusted depending on qdelay, its relation to the
   qdelay target, and the relation between the congestion window and the
   number of bytes in flight.  A strict rule is applied when qdelay is
   higher than qdelay_target, to avoid further queue buildup in the
   network.  For cases when qdelay is lower than the qdelay_target, a
   more relaxed rule is applied.  This allows the bitrate to increase
   quickly when no congestion is detected while still being able to
   exhibit stable behavior in congested situations.<a href="#section-4.1.2.5-4" class="pilcrow">¶</a></p>
<p id="section-4.1.2.5-5">The send window is given by the relation between the adjusted
   congestion window and the amount of bytes in flight according to the
   pseudocode below.<a href="#section-4.1.2.5-5" class="pilcrow">¶</a></p>
<div class="sourcecode" id="section-4.1.2.5-6">
<pre>&lt;CODE BEGINS&gt;
   calculate_send_window(qdelay, qdelay_target)
     # send window is computed differently depending on congestion level
     if (qdelay &lt;= qdelay_target)
       send_wnd = cwnd + MSS - bytes_in_flight
     else
       send_wnd = cwnd - bytes_in_flight
     end

&lt;CODE ENDS&gt;</pre><a href="#section-4.1.2.5-6" class="pilcrow">¶</a>
</div>
<p id="section-4.1.2.5-7">The send window is updated whenever an RTP packet is transmitted or
   an RTCP feedback messaged is received.<a href="#section-4.1.2.5-7" class="pilcrow">¶</a></p>
</section>
</div>
<div id="packet-pacing">
<section id="section-4.1.2.6">
            <h5 id="name-packet-pacing">
<a href="#section-4.1.2.6" class="section-number selfRef">4.1.2.6. </a><a href="#name-packet-pacing" class="section-name selfRef">Packet Pacing</a>
            </h5>
<p id="section-4.1.2.6-1">Packet pacing is used in order to mitigate coalescing, i.e., when
   packets are transmitted in bursts, with the risks of increased jitter
   and potentially increased packet loss.  Packet pacing also mitigates
   possible issues with queue overflow due to key-frame generation in
   video coders.  The time interval between consecutive packet
   transmissions is greater than or equal to t_pace, where t_pace is
   given by the equations below :<a href="#section-4.1.2.6-1" class="pilcrow">¶</a></p>
<div class="sourcecode" id="section-4.1.2.6-2">
<pre>&lt;CODE BEGINS&gt;
      pace_bitrate = max (RATE_PACE_MIN, cwnd * 8 / s_rtt)
      t_pace = rtp_size * 8 / pace_bitrate

&lt;CODE ENDS&gt;</pre><a href="#section-4.1.2.6-2" class="pilcrow">¶</a>
</div>
<p id="section-4.1.2.6-3">rtp_size is the size of the last transmitted RTP packet, and s_rtt is
   the smoothed round trip time.  RATE_PACE_MIN is the minimum pacing
   rate.<a href="#section-4.1.2.6-3" class="pilcrow">¶</a></p>
</section>
</div>
<div id="resuming-fast-increase-mode">
<section id="section-4.1.2.7">
            <h5 id="name-resuming-fast-increase-mode">
<a href="#section-4.1.2.7" class="section-number selfRef">4.1.2.7. </a><a href="#name-resuming-fast-increase-mode" class="section-name selfRef">Resuming Fast Increase Mode</a>
            </h5>
<p id="section-4.1.2.7-1">Fast increase mode can resume in order to speed up the bitrate
   increase if congestion abates.  The condition to resume fast increase
   mode (in_fast_increase = true) is that qdelay_trend is less than
   QDELAY_TREND_LO for T_RESUME_FAST_INCREASE seconds or more.<a href="#section-4.1.2.7-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="stream-prioritization">
<section id="section-4.1.2.8">
            <h5 id="name-stream-prioritization">
<a href="#section-4.1.2.8" class="section-number selfRef">4.1.2.8. </a><a href="#name-stream-prioritization" class="section-name selfRef">Stream Prioritization</a>
            </h5>
<p id="section-4.1.2.8-1">The SCReAM algorithm makes a good distinction between network
   congestion control and media rate control.  This is easily extended
   to many streams -- RTP packets from two or more RTP queues are
   scheduled at the rate permitted by the network congestion control.<a href="#section-4.1.2.8-1" class="pilcrow">¶</a></p>
<p id="section-4.1.2.8-2">The scheduling can be done by means of a few different scheduling
   regimes.  For example, the method for coupled congestion control
   specified in <span>[<a href="#RFC8699" class="cite xref">RFC8699</a>]</span> can be used.  One implementation of SCReAM
   <span>[<a href="#SCReAM-CPP-implementation" class="cite xref">SCReAM-CPP-implementation</a>]</span> uses credit-based scheduling.  In credit-
   based scheduling, credit is accumulated by queues as they wait for
   service and is spent while the queues are being serviced.  For
   instance, if one queue is allowed to transmit 1000 bytes, then a
   credit of 1000 bytes is allocated to the other unscheduled queues.
   This principle can be extended to weighted scheduling, where the
   credit allocated to unscheduled queues depends on the relative
   weights.  The latter is also implemented in
   <span>[<a href="#SCReAM-CPP-implementation" class="cite xref">SCReAM-CPP-implementation</a>]</span>.<a href="#section-4.1.2.8-2" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="media-rate-control-1">
<section id="section-4.1.3">
          <h4 id="name-media-rate-control-2">
<a href="#section-4.1.3" class="section-number selfRef">4.1.3. </a><a href="#name-media-rate-control-2" class="section-name selfRef">Media Rate Control</a>
          </h4>
<p id="section-4.1.3-1">The media rate control algorithm is executed at regular intervals,
   indicated by RATE_ADJUSTMENT_INTERVAL, with the exception of a prompt
   reaction to loss events.  The media rate control operates based on
   the size of the RTP packet send queue and observed loss events.  In
   addition, qdelay_trend is also considered in the media rate control
   in order to reduce the amount of induced network jitter.<a href="#section-4.1.3-1" class="pilcrow">¶</a></p>
<p id="section-4.1.3-2">The role of the media rate control is to strike a reasonable balance
   between a low amount of queuing in the RTP queue(s) and a sufficient
   amount of data to send in order to keep the data path busy.  Setting
   the media rate control too cautiously leads to possible
   underutilization of network capacity; this can cause the flow to
   become starved out by other more opportunistic traffic.  On the other
   hand, setting it too aggressively leads to increased jitter.<a href="#section-4.1.3-2" class="pilcrow">¶</a></p>
<p id="section-4.1.3-3">The target_bitrate is adjusted depending on the congestion state.
   The target bitrate can vary between a minimum value
   (TARGET_BITRATE_MIN) and a maximum value (TARGET_BITRATE_MAX).
   TARGET_BITRATE_MIN SHOULD be set to a low enough value to prevent RTP
   packets from becoming queued up when the network throughput is
   reduced.  The sender SHOULD also be equipped with a mechanism that
   discards RTP packets when the network throughput becomes very low and
   RTP packets are excessively delayed.<a href="#section-4.1.3-3" class="pilcrow">¶</a></p>
<p id="section-4.1.3-4">For the overall bitrate adjustment, two network throughput estimates
   are computed :<a href="#section-4.1.3-4" class="pilcrow">¶</a></p>
<p id="section-4.1.3-5">o  rate_transmit: The measured transmit bitrate.<a href="#section-4.1.3-5" class="pilcrow">¶</a></p>
<p id="section-4.1.3-6">o  rate_ack: The ACKed bitrate, i.e., the volume of ACKed bits per
      second.<a href="#section-4.1.3-6" class="pilcrow">¶</a></p>
<p id="section-4.1.3-7">Both estimates are updated every 200 ms.<a href="#section-4.1.3-7" class="pilcrow">¶</a></p>
<p id="section-4.1.3-8">The current throughput, current_rate, is computed as the maximum
   value of rate_transmit and rate_ack.  The rationale behind the use of
   rate_ack in addition to rate_transmit is that rate_transmit is
   affected also by the amount of data that is available to transmit,
   thus a lack of data to transmit can be seen as reduced throughput
   that can cause an unnecessary rate reduction.  To overcome this
   shortcoming, rate_ack is used as well.  This gives a more stable
   throughput estimate.<a href="#section-4.1.3-8" class="pilcrow">¶</a></p>
<p id="section-4.1.3-9">The rate change behavior depends on whether a loss or ECN event has
   occurred and whether the congestion control is in fast increase mode.<a href="#section-4.1.3-9" class="pilcrow">¶</a></p>
<div class="breakable sourcecode" id="section-4.1.3-10">
<pre>&lt;CODE BEGINS&gt;
   # The target_bitrate is updated at a regular interval according
   # to RATE_ADJUST_INTERVAL

   on loss:
      # Loss event detected
      target_bitrate = max(BETA_R * target_bitrate,
                           TARGET_BITRATE_MIN)
      exit
   on ecn_mark:
      # ECN event detected
      target_bitrate = max(BETA_ECN * target_bitrate,
                           TARGET_BITRATE_MIN)
      exit

   ramp_up_speed_t = min(RAMP_UP_SPEED, target_bitrate / 2.0)
   scale_t = (target_bitrate - target_bitrate_last_max) /
        target_bitrate_last_max
   scale_t = max(0.2, min(1.0, (scale_t * 4)^2))
   # min scale_t value 0.2, as the bitrate should be allowed to
   #  increase slowly. This prevents locking the rate to
   #  target_bitrate_last_max
   if (in_fast_increase = true)
      increment_t = ramp_up_speed_t * RATE_ADJUST_INTERVAL
      increment_t *= scale_t
      target_bitrate += increment_t
   else
      current_rate_t = max(rate_transmit, rate_ack)
      # Compute a bitrate change
      delta_rate_t = current_rate_t * (1.0 - PRE_CONGESTION_GUARD *
           queue_delay_trend) - TX_QUEUE_SIZE_FACTOR * rtp_queue_size
      # Limit a positive increase if close to target_bitrate_last_max
      if (delta_rate_t &gt; 0)
        delta_rate_t *= scale_t
        delta_rate_t =
          min(delta_rate_t, ramp_up_speed_t * RATE_ADJUST_INTERVAL)
      end
      target_bitrate += delta_rate_t
      # Force a slight reduction in bitrate if RTP queue
      #  builds up
      rtp_queue_delay_t = rtp_queue_size / current_rate_t
      if (rtp_queue_delay_t &gt; RTP_QDELAY_TH)
        target_bitrate *= TARGET_RATE_SCALE_RTP_QDELAY
      end
   end

   rate_media_limit_t =
      max(current_rate_t, max(rate_media, rtp_rate_median))
   rate_media_limit_t *= (2.0 - qdelay_trend_mem)
   target_bitrate = min(target_bitrate, rate_media_limit_t)
   target_bitrate = min(TARGET_BITRATE_MAX,
      max(TARGET_BITRATE_MIN, target_bitrate))

&lt;CODE ENDS&gt;</pre><a href="#section-4.1.3-10" class="pilcrow">¶</a>
</div>
<p id="section-4.1.3-11">In case of a loss event, the target_bitrate is updated and the rate
   change procedure is exited.  Otherwise, the rate change procedure
   continues.  The rationale behind the rate reduction due to loss is
   that a congestion window reduction will take effect, and a rate
   reduction proactively prevents RTP packets from being queued up when
   the transmit rate decreases due to the reduced congestion window.  A
   similar rate reduction happens when ECN events are detected.<a href="#section-4.1.3-11" class="pilcrow">¶</a></p>
<p id="section-4.1.3-12">The rate update frequency is limited by RATE_ADJUST_INTERVAL, unless
   a loss event occurs.  The value is based on experimentation with
   real-life limitations in video coders taken into account
   <span>[<a href="#SCReAM-CPP-implementation" class="cite xref">SCReAM-CPP-implementation</a>]</span>.  A too short interval is shown to make
   the rate control loop in video coders more unstable; a too long
   interval makes the overall congestion control sluggish.<a href="#section-4.1.3-12" class="pilcrow">¶</a></p>
<p id="section-4.1.3-13">When in fast increase mode (in_fast_increase = true), the bitrate
   increase is given by the desired ramp-up speed (RAMP_UP_SPEED).  The
   ramp-up speed is limited when the target bitrate is low to avoid rate
   oscillation at low bottleneck bitrates.  The setting of RAMP_UP_SPEED
   depends on preferences.  A high setting such as 1000 kbps/s makes it
   possible to quickly get high-quality media; however, this is at the
   expense of increased jitter, which can manifest itself as choppy
   video rendering, for example.<a href="#section-4.1.3-13" class="pilcrow">¶</a></p>
<p id="section-4.1.3-14">When in_fast_increase is false, the bitrate increase is given by the
   current bitrate and is also controlled by the estimated RTP queue and
   the qdelay trend, thus it is sufficient that an increased congestion
   level is sensed by the network congestion control to limit the
   bitrate.  The target_bitrate_last_max is updated when congestion is
   detected.<a href="#section-4.1.3-14" class="pilcrow">¶</a></p>
<p id="section-4.1.3-15">Finally, the target_bitrate is within the defined min and max values.<a href="#section-4.1.3-15" class="pilcrow">¶</a></p>
<p id="section-4.1.3-16">The aware reader may notice the dependency on the qdelay in the
   computation of the target bitrate; this manifests itself in the use
   of the qdelay_trend.  As these parameters are used also in the
   network congestion control, one may suspect some odd interaction
   between the media rate control and the network congestion control.
   This is in fact the case if the parameter PRE_CONGESTION_GUARD is set
   to a high value.  The use of qdelay_trend in the media rate control
   is solely to reduce jitter; the dependency can be removed by setting
   PRE_CONGESTION_GUARD=0.  The effect is a somewhat larger rate
   increase after congestion, at the expense of increased jitter in
   congested situations.<a href="#section-4.1.3-16" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="scream-receiver">
<section id="section-4.2">
        <h3 id="name-scream-receiver">
<a href="#section-4.2" class="section-number selfRef">4.2. </a><a href="#name-scream-receiver" class="section-name selfRef">SCReAM Receiver</a>
        </h3>
<p id="section-4.2-1">The simple task of the SCReAM receiver is to feed back
   acknowledgements of received packets and total ECN count to the
   SCReAM sender.  In addition, the receive time of the RTP packet with
   the highest sequence number is echoed back.  Upon reception of each
   RTP packet, the receiver MUST maintain enough information to send the
   aforementioned values to the SCReAM sender via an RTCP transport-
   layer feedback message.  The frequency of the feedback message
   depends on the available RTCP bandwidth.  The requirements on the
   feedback elements and the feedback interval are described below.<a href="#section-4.2-1" class="pilcrow">¶</a></p>
<div id="requirements-on-feedback-elements">
<section id="section-4.2.1">
          <h4 id="name-requirements-on-feedback-el">
<a href="#section-4.2.1" class="section-number selfRef">4.2.1. </a><a href="#name-requirements-on-feedback-el" class="section-name selfRef">Requirements on Feedback Elements</a>
          </h4>
<p id="section-4.2.1-1">The following feedback elements are REQUIRED for basic functionality
   in SCReAM.<a href="#section-4.2.1-1" class="pilcrow">¶</a></p>
<p id="section-4.2.1-2">o  A list of received RTP packets.  This list SHOULD be sufficiently
      long to cover all received RTP packets.  This list can be realized
      with the Loss RLE (Run Length Encoding) Report Block in <span>[<a href="#RFC3611" class="cite xref">RFC3611</a>]</span>.<a href="#section-4.2.1-2" class="pilcrow">¶</a></p>
<p id="section-4.2.1-3">o  A wall-clock timestamp corresponding to the received RTP packet
      with the highest sequence number is required in order to compute
      the qdelay.  This can be realized by means of the Packet Receipt
      Times Report Block in <span>[<a href="#RFC3611" class="cite xref">RFC3611</a>]</span>.  begin_seq MUST be set to the
      highest received sequence number (which has possibly wrapped
      around); end_seq MUST be set to begin_seq+1 modulo 65536.  The
      timestamp clock MAY be set according to <span>[<a href="#RFC3611" class="cite xref">RFC3611</a>]</span>, i.e., equal to
      the RTP timestamp clock.  Detailed individual packet receive times
      are not necessary, as SCReAM does currently not describe how they
      can be used.<a href="#section-4.2.1-3" class="pilcrow">¶</a></p>
<p id="section-4.2.1-4">The basic feedback needed for SCReAM involves the use of the Loss RLE
   Report Block and the Packet Receipt Times Report Block as shown in
   <a href="#feedback-msg" class="auto internal xref">Figure 2</a>.<a href="#section-4.2.1-4" class="pilcrow">¶</a></p>
<span id="name-basic-feedback-message-for-"></span><div id="feedback-msg">
<figure id="figure-2">
            <div class="alignLeft art-text artwork" id="section-4.2.1-5.1">
<pre>
        0                   1                   2                   3
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |V=2|P|reserved |   PT=XR=207   |             length            |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                              SSRC                             |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |     BT=2      | rsvd. |  T=0  |         block length          |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                        SSRC of source                         |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |          begin_seq            |             end_seq           |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |          chunk 1              |             chunk 2           |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       :                              ...                              :
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |          chunk n-1            |             chunk n           |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |     BT=3      | rsvd. |  T=0  |         block length          |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                        SSRC of source                         |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |          begin_seq            |             end_seq           |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |       Receipt time of packet begin_seq                        |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
</div>
<figcaption><a href="#figure-2" class="selfRef">Figure 2</a>:
<a href="#name-basic-feedback-message-for-" class="selfRef">Basic Feedback Message for SCReAM, Based on RFC 3611</a>
            </figcaption></figure>
</div>
<p id="section-4.2.1-6">In a typical use case, no more than four Loss RLE chunks are needed,
   thus the feedback message will be 44 bytes.  It is obvious from
   Figure 2 that there is a lot of redundant information in the feedback
   message.  A more optimized feedback format, including the additional
   feedback elements listed below, could reduce the feedback message
   size a bit.<a href="#section-4.2.1-6" class="pilcrow">¶</a></p>
<p id="section-4.2.1-7">An additional feedback element that can improve the performance of
   SCReAM is:<a href="#section-4.2.1-7" class="pilcrow">¶</a></p>
<p id="section-4.2.1-8">o  Accumulated number of ECN-CE-marked packets (n_ECN).  For
      instance, this can be realized with the ECN Feedback Report Format
      in <span>[<a href="#RFC6679" class="cite xref">RFC6679</a>]</span>.  The given feedback report format is slightly
      overkill, as SCReAM would do quite well with only a counter that
      increments by one for each received packet with the ECN-CE
      codepoint set.  The more bulky format could nevertheless be useful
      for, e.g., ECN black-hole detection.<a href="#section-4.2.1-8" class="pilcrow">¶</a></p>
</section>
</div>
<div id="requirements-on-feedback-intensity">
<section id="section-4.2.2">
          <h4 id="name-requirements-on-feedback-in">
<a href="#section-4.2.2" class="section-number selfRef">4.2.2. </a><a href="#name-requirements-on-feedback-in" class="section-name selfRef">Requirements on Feedback Intensity</a>
          </h4>
<p id="section-4.2.2-1">SCReAM benefits from relatively frequent feedback.  It is RECOMMENDED
   that a SCReAM implementation follows the guidelines below.<a href="#section-4.2.2-1" class="pilcrow">¶</a></p>
<p id="section-4.2.2-2">The feedback interval depends on the media bitrate.  At low bitrates,
   it is sufficient with a feedback interval of 100 to 400 ms; while at
   high bitrates, a feedback interval of roughly 20 ms is preferred.  At
   very high bitrates, even shorter feedback intervals MAY be needed in
   order to keep the self-clocking in SCReAM working well.  One
   indication that feedback is too sparse is that the SCReAM
   implementation cannot reach high bitrates, even in uncongested links.
   More frequent feedback might solve this issue.<a href="#section-4.2.2-2" class="pilcrow">¶</a></p>
<p id="section-4.2.2-3">The numbers above can be formulated as a feedback interval function
   that can be useful for the computation of the desired RTCP bandwidth.
   The following equation expresses the feedback rate:<a href="#section-4.2.2-3" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-4.2.2-4">
<pre>
  rate_fb = min(50, max(2.5, rate_media / 10000))
</pre><a href="#section-4.2.2-4" class="pilcrow">¶</a>
</div>
<p id="section-4.2.2-5">rate_media is the RTP media bitrate expressed in bps; rate_fb is the
   feedback rate expressed in packets/s.  Converting to feedback
   interval, we get:<a href="#section-4.2.2-5" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-4.2.2-6">
<pre>
  fb_int = 1.0 / min(50, max(2.5, rate_media / 10000))
</pre><a href="#section-4.2.2-6" class="pilcrow">¶</a>
</div>
<p id="section-4.2.2-7">The transmission interval is not critical.  So, in the case of multi-
   stream handling between two hosts, the feedback for two or more
   synchronization sources (SSRCs) can be bundled to save UDP/IP
   overhead.  However, the final realized feedback interval SHOULD not
   exceed 2*fb_int in such cases, meaning that a scheduled feedback
   transmission event should not be delayed more than fb_int.<a href="#section-4.2.2-7" class="pilcrow">¶</a></p>
<p id="section-4.2.2-8">SCReAM works with AVPF regular mode; immediate or early mode is not
   required by SCReAM but can nonetheless be useful for RTCP messages
   not directly related to SCReAM, such as those specified in <span>[<a href="#RFC4585" class="cite xref">RFC4585</a>]</span>.
   It is RECOMMENDED to use reduced-size RTCP <span>[<a href="#RFC5506" class="cite xref">RFC5506</a>]</span>, where regular
   full compound RTCP transmission is controlled by trr-int as described
   in <span>[<a href="#RFC4585" class="cite xref">RFC4585</a>]</span>.<a href="#section-4.2.2-8" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
</section>
</div>
<div id="discussion">
<section id="section-5">
      <h2 id="name-discussion">
<a href="#section-5" class="section-number selfRef">5. </a><a href="#name-discussion" class="section-name selfRef">Discussion</a>
      </h2>
<p id="section-5-1">This section covers a few discussion points.<a href="#section-5-1" class="pilcrow">¶</a></p>
<p id="section-5-2">o  Clock drift: SCReAM can suffer from the same issues with clock
      drift as is the case with LEDBAT <span>[<a href="#RFC6817" class="cite xref">RFC6817</a>]</span>.  However, Appendix A.2
      in <span>[<a href="#RFC6817" class="cite xref">RFC6817</a>]</span> describes ways to mitigate issues with clock drift.<a href="#section-5-2" class="pilcrow">¶</a></p>
<p id="section-5-3">o  Support for alternate ECN semantics: This specification adopts the
      proposal in <span>[<a href="#RFC8511" class="cite xref">RFC8511</a>]</span> to reduce the congestion window less
      when ECN-based congestion events are detected.  Future work on Low
      Loss, Low Latency for Scalable throughput (L4S) may lead to
      updates in a future document that describes SCReAM support for
      L4S.<a href="#section-5-3" class="pilcrow">¶</a></p>
<p id="section-5-4">o  A new transport-layer feedback message (as specified in RFC 4585)
      could be standardized if the use of the already existing RTCP
      extensions as described in Section 4.2 is not deemed sufficient.<a href="#section-5-4" class="pilcrow">¶</a></p>
<p id="section-5-5">o  The target bitrate given by SCReAM is the bitrate including the
      RTP and Forward Error Correction (FEC) overhead.  The media
      encoder SHOULD take this overhead into account when the media
      bitrate is set.  This means that the media coder bitrate SHOULD be
      computed as<a href="#section-5-5" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-5-6">
<pre>
  media_rate = target_bitrate - rtp_plus_fec_overhead_bitrate

  It is not necessary to make a 100% perfect compensation for the
  overhead, as the SCReAM algorithm will inherently compensate for
  moderate errors.  Under-compensating for the overhead has the
  effect of increasing jitter, while overcompensating will cause the
  bottleneck link to become underutilized.
</pre><a href="#section-5-6" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="suggested-experiments">
<section id="section-6">
      <h2 id="name-suggested-experiments">
<a href="#section-6" class="section-number selfRef">6. </a><a href="#name-suggested-experiments" class="section-name selfRef">Suggested Experiments</a>
      </h2>
<p id="section-6-1">SCReAM has been evaluated in a number of different ways, mostly in a
   simulator.  The OpenWebRTC implementation work (<span>[<a href="#OpenWebRTC" class="cite xref">OpenWebRTC</a>]</span> and
   <span>[<a href="#SCReAM-implementation" class="cite xref">SCReAM-implementation</a>]</span>) involved extensive testing with artificial
   bottlenecks with varying bandwidths and using two different video
   coders (OpenH264 and VP9).<a href="#section-6-1" class="pilcrow">¶</a></p>
<p id="section-6-2">Preferably, further experiments will be done by means of
   implementation in real clients and web browsers.  RECOMMENDED
   experiments are:<a href="#section-6-2" class="pilcrow">¶</a></p>
<p id="section-6-3">o  Trials with various access technologies: EDGE/3G/4G, Wi-Fi, DSL.
      Some experiments have already been carried out with LTE access;
      see <span>[<a href="#SCReAM-CPP-implementation" class="cite xref">SCReAM-CPP-implementation</a>]</span> and
      <span>[<a href="#SCReAM-implementation-experience" class="cite xref">SCReAM-implementation-experience</a>]</span>.<a href="#section-6-3" class="pilcrow">¶</a></p>
<p id="section-6-4">o  Trials with different kinds of media: Audio, video, slideshow
      content.  Evaluation of multi-stream handling in SCReAM.<a href="#section-6-4" class="pilcrow">¶</a></p>
<p id="section-6-5">o  Evaluation of functionality of the compensation mechanism when
      there are competing flows: Evaluate how SCReAM performs with
      competing TCP-like traffic and to what extent the compensation for
      competing flows causes self-inflicted congestion.<a href="#section-6-5" class="pilcrow">¶</a></p>
<p id="section-6-6">o  Determine proper parameters: A set of default parameters are given
      that makes SCReAM work over a reasonably large operation range.
      However, for very low or very high bitrates, it may be necessary
      to use different values for the RAMP_UP_SPEED, for instance.<a href="#section-6-6" class="pilcrow">¶</a></p>
<p id="section-6-7">o  Experimentation with further improvements to the congestion window
      and media bitrate calculation.  <span>[<a href="#SCReAM-CPP-implementation" class="cite xref">SCReAM-CPP-implementation</a>]</span>
      implements some optimizations, not described in this memo, that
      improve performance slightly.  Further experiments are likely to
      lead to more optimizations of the algorithm.<a href="#section-6-7" class="pilcrow">¶</a></p>
</section>
</div>
<div id="iana-considerations">
<section id="section-7">
      <h2 id="name-iana-considerations">
<a href="#section-7" class="section-number selfRef">7. </a><a href="#name-iana-considerations" class="section-name selfRef">IANA Considerations</a>
      </h2>
<p id="section-7-1">This document does not require any IANA actions.<a href="#section-7-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="security-considerations">
<section id="section-8">
      <h2 id="name-security-considerations">
<a href="#section-8" class="section-number selfRef">8. </a><a href="#name-security-considerations" class="section-name selfRef">Security Considerations</a>
      </h2>
<p id="section-8-1">The feedback can be vulnerable to attacks similar to those that can
   affect TCP.  It is therefore RECOMMENDED that the RTCP feedback is at
   least integrity protected.  Furthermore, as SCReAM is self-clocked, a
   malicious middlebox can drop RTCP feedback packets and thus cause the
   self-clocking in SCReAM to stall.  However, this attack is mitigated
   by the minimum send rate maintained by SCReAM when no feedback is
   received.<a href="#section-8-1" class="pilcrow">¶</a></p>
</section>
</div>
<section id="section-9">
      <h2 id="name-references">
<a href="#section-9" class="section-number selfRef">9. </a><a href="#name-references" class="section-name selfRef">References</a>
      </h2>
<div id="sec-normative-references">
<section id="section-9.1">
        <h3 id="name-normative-references">
<a href="#section-9.1" class="section-number selfRef">9.1. </a><a href="#name-normative-references" class="section-name selfRef">Normative References</a>
        </h3>
<dl class="references">
<dt id="RFC3550">[RFC3550]</dt>
        <dd>
<span class="refAuthor">Schulzrinne, H.</span>, <span class="refAuthor">Casner, S.</span>, <span class="refAuthor">Frederick, R.</span>, and <span class="refAuthor">V. Jacobson</span>, <span class="refTitle">"RTP: A Transport Protocol for Real-Time Applications"</span>, <span class="seriesInfo">STD 64</span>, <span class="seriesInfo">RFC 3550</span>, <span class="seriesInfo">DOI 10.17487/RFC3550</span>, <time datetime="2003-07" class="refDate">July 2003</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc3550">https://www.rfc-editor.org/info/rfc3550</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC3611">[RFC3611]</dt>
        <dd>
<span class="refAuthor">Friedman, T., Ed.</span>, <span class="refAuthor">Caceres, R., Ed.</span>, and <span class="refAuthor">A. Clark, Ed.</span>, <span class="refTitle">"RTP Control Protocol Extended Reports (RTCP XR)"</span>, <span class="seriesInfo">RFC 3611</span>, <span class="seriesInfo">DOI 10.17487/RFC3611</span>, <time datetime="2003-11" class="refDate">November 2003</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc3611">https://www.rfc-editor.org/info/rfc3611</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC4585">[RFC4585]</dt>
        <dd>
<span class="refAuthor">Ott, J.</span>, <span class="refAuthor">Wenger, S.</span>, <span class="refAuthor">Sato, N.</span>, <span class="refAuthor">Burmeister, C.</span>, and <span class="refAuthor">J. Rey</span>, <span class="refTitle">"Extended RTP Profile for Real-time Transport Control Protocol (RTCP)-Based Feedback (RTP/AVPF)"</span>, <span class="seriesInfo">RFC 4585</span>, <span class="seriesInfo">DOI 10.17487/RFC4585</span>, <time datetime="2006-07" class="refDate">July 2006</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc4585">https://www.rfc-editor.org/info/rfc4585</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC5506">[RFC5506]</dt>
        <dd>
<span class="refAuthor">Johansson, I.</span> and <span class="refAuthor">M. Westerlund</span>, <span class="refTitle">"Support for Reduced-Size Real-Time Transport Control Protocol (RTCP): Opportunities and Consequences"</span>, <span class="seriesInfo">RFC 5506</span>, <span class="seriesInfo">DOI 10.17487/RFC5506</span>, <time datetime="2009-04" class="refDate">April 2009</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc5506">https://www.rfc-editor.org/info/rfc5506</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC6298">[RFC6298]</dt>
        <dd>
<span class="refAuthor">Paxson, V.</span>, <span class="refAuthor">Allman, M.</span>, <span class="refAuthor">Chu, J.</span>, and <span class="refAuthor">M. Sargent</span>, <span class="refTitle">"Computing TCP's Retransmission Timer"</span>, <span class="seriesInfo">RFC 6298</span>, <span class="seriesInfo">DOI 10.17487/RFC6298</span>, <time datetime="2011-06" class="refDate">June 2011</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc6298">https://www.rfc-editor.org/info/rfc6298</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC6817">[RFC6817]</dt>
        <dd>
<span class="refAuthor">Shalunov, S.</span>, <span class="refAuthor">Hazel, G.</span>, <span class="refAuthor">Iyengar, J.</span>, and <span class="refAuthor">M. Kuehlewind</span>, <span class="refTitle">"Low Extra Delay Background Transport (LEDBAT)"</span>, <span class="seriesInfo">RFC 6817</span>, <span class="seriesInfo">DOI 10.17487/RFC6817</span>, <time datetime="2012-12" class="refDate">December 2012</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc6817">https://www.rfc-editor.org/info/rfc6817</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8174">[RFC8174]</dt>
      <dd>
<span class="refAuthor">Leiba, B.</span>, <span class="refTitle">"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words"</span>, <span class="seriesInfo">BCP 14</span>, <span class="seriesInfo">RFC 8174</span>, <span class="seriesInfo">DOI 10.17487/RFC8174</span>, <time datetime="2017-05" class="refDate">May 2017</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8174">https://www.rfc-editor.org/info/rfc8174</a>&gt;</span>. </dd>
<dd class="break"></dd>
</dl>
</section>
</div>
<div id="sec-informative-references">
<section id="section-9.2">
        <h3 id="name-informative-references">
<a href="#section-9.2" class="section-number selfRef">9.2. </a><a href="#name-informative-references" class="section-name selfRef">Informative References</a>
        </h3>
<dl class="references">
<dt id="RFC2119">[RFC2119]</dt>
        <dd>
<span class="refAuthor">Bradner, S.</span>, <span class="refTitle">"Key words for use in RFCs to Indicate Requirement Levels"</span>, <span class="seriesInfo">BCP 14</span>, <span class="seriesInfo">RFC 2119</span>, <span class="seriesInfo">DOI 10.17487/RFC2119</span>, <time datetime="1997-03" class="refDate">March 1997</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc2119">https://www.rfc-editor.org/info/rfc2119</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC6679">[RFC6679]</dt>
        <dd>
<span class="refAuthor">Westerlund, M.</span>, <span class="refAuthor">Johansson, I.</span>, <span class="refAuthor">Perkins, C.</span>, <span class="refAuthor">O'Hanlon, P.</span>, and <span class="refAuthor">K. Carlberg</span>, <span class="refTitle">"Explicit Congestion Notification (ECN) for RTP over UDP"</span>, <span class="seriesInfo">RFC 6679</span>, <span class="seriesInfo">DOI 10.17487/RFC6679</span>, <time datetime="2012-08" class="refDate">August 2012</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc6679">https://www.rfc-editor.org/info/rfc6679</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC7478">[RFC7478]</dt>
        <dd>
<span class="refAuthor">Holmberg, C.</span>, <span class="refAuthor">Hakansson, S.</span>, and <span class="refAuthor">G. Eriksson</span>, <span class="refTitle">"Web Real-Time Communication Use Cases and Requirements"</span>, <span class="seriesInfo">RFC 7478</span>, <span class="seriesInfo">DOI 10.17487/RFC7478</span>, <time datetime="2015-03" class="refDate">March 2015</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc7478">https://www.rfc-editor.org/info/rfc7478</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC7661">[RFC7661]</dt>
        <dd>
<span class="refAuthor">Fairhurst, G.</span>, <span class="refAuthor">Sathiaseelan, A.</span>, and <span class="refAuthor">R. Secchi</span>, <span class="refTitle">"Updating TCP to Support Rate-Limited Traffic"</span>, <span class="seriesInfo">RFC 7661</span>, <span class="seriesInfo">DOI 10.17487/RFC7661</span>, <time datetime="2015-10" class="refDate">October 2015</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc7661">https://www.rfc-editor.org/info/rfc7661</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8298">[RFC8298]</dt>
        <dd>
<span class="refAuthor">Johansson, I.</span> and <span class="refAuthor">Z. Sarker</span>, <span class="refTitle">"Self-Clocked Rate Adaptation for Multimedia"</span>, <span class="seriesInfo">RFC 8298</span>, <span class="seriesInfo">DOI 10.17487/RFC8298</span>, <time datetime="2017-12" class="refDate">December 2017</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8298">https://www.rfc-editor.org/info/rfc8298</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8511">[RFC8511]</dt>
        <dd>
<span class="refAuthor">Khademi, N.</span>, <span class="refAuthor">Welzl, M.</span>, <span class="refAuthor">Armitage, G.</span>, and <span class="refAuthor">G. Fairhurst</span>, <span class="refTitle">"TCP Alternative Backoff with ECN (ABE)"</span>, <span class="seriesInfo">RFC 8511</span>, <span class="seriesInfo">DOI 10.17487/RFC8511</span>, <time datetime="2018-12" class="refDate">December 2018</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8511">https://www.rfc-editor.org/info/rfc8511</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8699">[RFC8699]</dt>
        <dd>
<span class="refAuthor">Islam, S.</span>, <span class="refAuthor">Welzl, M.</span>, and <span class="refAuthor">S. Gjessing</span>, <span class="refTitle">"Coupled Congestion Control for RTP Media"</span>, <span class="seriesInfo">RFC 8699</span>, <span class="seriesInfo">DOI 10.17487/RFC8699</span>, <time datetime="2020-01" class="refDate">January 2020</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8699">https://www.rfc-editor.org/info/rfc8699</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8869">[RFC8869]</dt>
        <dd>
<span class="refAuthor">Sarker, Z.</span>, <span class="refAuthor">Zhu, X.</span>, and <span class="refAuthor">J. Fu</span>, <span class="refTitle">"Evaluation Test Cases for Interactive Real-Time Media over Wireless Networks"</span>, <span class="seriesInfo">RFC 8869</span>, <span class="seriesInfo">DOI 10.17487/RFC8869</span>, <time datetime="2021-01" class="refDate">January 2021</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8869">https://www.rfc-editor.org/info/rfc8869</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8985">[RFC8985]</dt>
        <dd>
<span class="refAuthor">Cheng, Y.</span>, <span class="refAuthor">Cardwell, N.</span>, <span class="refAuthor">Dukkipati, N.</span>, and <span class="refAuthor">P. Jha</span>, <span class="refTitle">"The RACK-TLP Loss Detection Algorithm for TCP"</span>, <span class="seriesInfo">RFC 8985</span>, <span class="seriesInfo">DOI 10.17487/RFC8985</span>, <time datetime="2021-02" class="refDate">February 2021</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8985">https://www.rfc-editor.org/info/rfc8985</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="OpenWebRTC">[OpenWebRTC]</dt>
        <dd>
<span class="refAuthor">Ericsson Research</span>, <span class="refTitle">"OpenWebRTC"</span>, <span>n.d.</span>, <span>&lt;<a href="http://www.openwebrtc.org">http://www.openwebrtc.org</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="Packet-conservation">[Packet-conservation]</dt>
        <dd>
<span class="refAuthor">Jacobson, V.</span>, <span class="refTitle">"Congestion Avoidance and Control"</span>, <span class="refContent">ACM SIGCOMM Computer Communication Review</span>, <span class="seriesInfo">DOI 10.1145/52325.52356</span>, <time datetime="1988-08" class="refDate">August 1988</time>, <span>&lt;<a href="https://doi.org/10.1145/52325.52356">https://doi.org/10.1145/52325.52356</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="LEDBAT-delay-impact">[LEDBAT-delay-impact]</dt>
        <dd>
<span class="refAuthor">Ros, D.</span> and <span class="refAuthor">M. Welzl</span>, <span class="refTitle">"Assessing LEDBAT's Delay Impact"</span>, <span class="refContent">IEEE Communications Letters, Vol. 17, No. 5,</span>, <span class="seriesInfo">DOI 10.1109/LCOMM.2013.040213.130137</span>, <time datetime="2013-05" class="refDate">May 2013</time>, <span>&lt;<a href="http://home.ifi.uio.no/michawe/research/publications/ledbat-impact-letters.pdf">http://home.ifi.uio.no/michawe/research/publications/ledbat-impact-letters.pdf</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="QoS-3GPP">[QoS-3GPP]</dt>
        <dd>
<span class="refTitle">"Policy and charging control architecture"</span>, <span class="refContent">3GPP TS 23.203</span>, <time datetime="2017-07" class="refDate">July 2017</time>, <span>&lt;<a href="http://www.3gpp.org/ftp/specs/archive/23_series/23.203/">http://www.3gpp.org/ftp/specs/archive/23_series/23.203/</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="SCReAM-CPP-implementation">[SCReAM-CPP-implementation]</dt>
        <dd>
<span class="refAuthor">Ericsson Research</span>, <span class="refTitle">"SCReAM - Mobile optimised congestion control algorithm"</span>, <span>n.d.</span>, <span>&lt;<a href="https://github.com/EricssonResearch/scream">https://github.com/EricssonResearch/scream</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="SCReAM-implementation">[SCReAM-implementation]</dt>
        <dd>
<span class="refAuthor">Ericsson Research</span>, <span class="refTitle">"OpenWebRTC specific GStreamer plugins"</span>, <span>n.d.</span>, <span>&lt;<a href="https://github.com/EricssonResearch/openwebrtc-gst-plugins">https://github.com/EricssonResearch/openwebrtc-gst-plugins</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="SCReAM-implementation-experience">[SCReAM-implementation-experience]</dt>
        <dd>
<span class="refAuthor">Sarker, Z.</span> and <span class="refAuthor">I. Johansson</span>, <span class="refTitle">"Updates on SCReAM: An implementation experience"</span>, <time datetime="2015-11" class="refDate">November 2015</time>, <span>&lt;<a href="https://www.ietf.org/proceedings/94/slides/slides-94-rmcat-8.pdf">https://www.ietf.org/proceedings/94/slides/slides-94-rmcat-8.pdf</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="TFWC">[TFWC]</dt>
      <dd>
<span class="refAuthor">Choi, S.</span> and <span class="refAuthor">M. Handley</span>, <span class="refTitle">"Fairer TCP-Friendly Congestion Control Protocol for Multimedia Streaming Applications"</span>, <span class="seriesInfo">DOI 10.1145/1364654.1364717</span>, <time datetime="2007-12" class="refDate">December 2007</time>, <span>&lt;<a href="http://www-dept.cs.ucl.ac.uk/staff/M.Handley/papers/tfwc-conext.pdf">http://www-dept.cs.ucl.ac.uk/staff/M.Handley/papers/tfwc-conext.pdf</a>&gt;</span>. </dd>
<dd class="break"></dd>
</dl>
</section>
</div>
</section>
<div id="acknowledgments">
<section id="appendix-A">
      <h2 id="name-acknowledgments">
<a href="#appendix-A" class="section-number selfRef">Appendix A. </a><a href="#name-acknowledgments" class="section-name selfRef">Acknowledgments</a>
      </h2>
<p id="appendix-A-1">We would like to thank the following people for their comments,
   questions, and support during the work that led to this memo: Markus
   Andersson, Bo Burman, Tomas Frankkila, Frederic Gabin, Laurits Hamm,
   Hans Hannu, Nikolas Hermanns, Stefan Haakansson, Erlendur Karlsson,
   Daniel Lindstroem, Mats Nordberg, Jonathan Samuelsson, Rickard
   Sjoeberg, Robert Swain, Magnus Westerlund, and Stefan Aalund.  Many
   additional thanks to RMCAT chairs Karen E. E. Nielsen and Mirja
   Kuehlewind for patiently reading, suggesting improvements and also
   for asking all the difficult but necessary questions.  Thanks to
   Stefan Holmer, Xiaoqing Zhu, Safiqul Islam, and David Hayes for the
   additional review of this document.  Thanks to Ralf Globisch for
   taking time to try out SCReAM in his challenging low-bitrate use
   cases, Robert Hedman for finding a few additional flaws in the
   running code, and Gustavo Garcia and 'miseri' for code contributions.<a href="#appendix-A-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="authors-addresses">
<section id="appendix-B">
      <h2 id="name-authors-addresses">
<a href="#name-authors-addresses" class="section-name selfRef">Authors' Addresses</a>
      </h2>
<address class="vcard">
        <div dir="auto" class="left"><span class="fn nameRole">Ingemar Johansson</span></div>
<div dir="auto" class="left"><span class="org">Ericsson</span></div>
<div class="email">
<span>Email:</span>
<a href="mailto:ingemar.johansson@ericsson.com" class="email">ingemar.johansson@ericsson.com</a>
</div>
</address>
<address class="vcard">
        <div dir="auto" class="left"><span class="fn nameRole">Magnus Westerlund</span></div>
<div dir="auto" class="left"><span class="org">Ericsson</span></div>
<div class="email">
<span>Email:</span>
<a href="mailto:magnus.westerlund@ericsson.com" class="email">magnus.westerlund@ericsson.com</a>
</div>
</address>
</section>
</div>
<script>const toc = document.getElementById("toc");
toc.querySelector("h2").addEventListener("click", e => {
  toc.classList.toggle("active");
});
toc.querySelector("nav").addEventListener("click", e => {
  toc.classList.remove("active");
});
</script>
</body>
</html>
